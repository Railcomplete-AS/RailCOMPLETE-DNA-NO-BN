<!--========================================================================================================

    NO-BN-RC-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml" />.

	(c) Railcomplete AS, Norway, 2015-2021. All rights reserved.
	
=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
    RC general and railway-independent Lua
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
	<LuaFunction Name="RC__toint()" ReturnType="Collection,Int"
		Description="Returns a collection of objects connected through the specified relation, and the number of related objects found. Source object and visibility are optional arguments." >
		<Constructor>int RC__toint(double x)</Constructor>
		<Formula>function RC__toint(x) return string.format("%.0f",x) end</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getCollectionOfRelatedObjects()" ReturnType="Collection,Int"
		Description="Returns a collection of objects connected through the specified relation, and the number of related objects found. Source object and visibility are optional arguments." >
		<Constructor>Collection,Int RC__getCollectionOfRelatedObjects(String RelationName [,Reference SourceObject [,Boolean Invisible]])</Constructor>
		<Formula>
			function RC__getCollectionOfRelatedObjects(RelationName,Source,Invisible)
				if Invisible then Invisible = true else Invisible = false end
				Source = Source or this
				--Is source a real object reference with an id?
				if Source.id == nil then
					return {},0,_warning, _info("*** RC__getCollectionOfRelatedObjects: Bad source object reference '"..tostring(Source).."'.")
				end
				if RelationName == nil then
					return {},0,_warning, _info("Missing relation name in function call.")
				elseif Source.Relations == nil then
					return {},0,_warning, _info("*** RC__getCollectionOfRelatedObjects: No such relation '"..RelationName.."' for object type '"..Source.RcType.."'.")
				end
				local r = Source.Relations[RelationName]
				if r == nil then
					return {},0
				elseif Invisible then
					return r,getCollectionLength(r)
				else
					r = r:filter(function (x) return x:isVisible() end)
					return r,getCollectionLength(r)
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getTextAttributeAcsPosition()" ReturnType="Vector2D" 
			HideFromUser="false"
			Description="Returns a World Coordinate System offset vector in the current drawing scale for a text attribute. Input coordinates provide the acsX = lateral offset (positive to the right side of the object's alignment) and the acsY = longitudinal offset (positive in the direction of increasing mileages), both stated for drawing scale 1:1 (1:1000)." >
		<Constructor>{Double,Double} RC__getTextAttributeAcsPosition(Double lateralOffset, Double longitudinalOffset)</Constructor>
		<Formula>
			function RC__getTextAttributeAcsPosition(lateralOffset,longitudinalOffset)
				scale = DocumentData.Document.Database.Cannoscale.Scale --CAD system's annotative scale
				lateralOffset = (lateralOffset or 5)/scale
				longitudinalOffset = (longitudinalOffset or 0)/scale
				return RC__getWcsVectorFromAcsVector(RightSided and lateralOffset or -lateralOffset,longitudinalOffset)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngleFromDir()" ReturnType="Double"
		Description="Returns the angle in Decimal Degrees corresponding to the given direction [up | down | both | none | unknown]. 'Direction' and 'Rightsided' are optional arguments." >
		<Constructor>Double RC__getAngleFromDir([LaxDirection Direction [,Boolean RightSided]])</Constructor>
		<Formula>
			function RC__getAngleFromDir(d,rs)
				if d == nil then
					d = dir
					rs = RightSided
				elseif rs == nil then
					rs = false
				end
				if dir == 'up' then return 0
				elseif dir == 'down' then return 180
				elseif dir == 'both' then return rs and -90 or 90
				elseif dir == 'none' then return rs and 90 or -90 
				elseif dir == 'unknown' then return 45 
				else return 45, _info("Bad direction '"..d.."'.")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getMileageFromRelatedObject()" ReturnType="Double"
		Description="Returns the mileage for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getMileageFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getMileageFromRelatedObject(RelationName,Source)
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Mileage"),_warning, _info("Missing relation name in function call.")
				end
				local r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Mileage"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDistanceToAlignmentFromRelatedObject()" ReturnType="Double"
		Description="Returns the distance to alignment for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getDistanceToAlignmentFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getDistanceToAlignmentFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("DistanceToAlignment"),_warning, _info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("DistanceToAlignment"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("DistanceToAlignment deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("DistanceToAlignment deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getRelativeElevationFromRelatedObject()" ReturnType="Double"
		Description="Returns the relative elevation above for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getRelativeElevationFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getRelativeElevationFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("RelativeElevation"),_warning, _info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("RelativeElevation"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("RelativeElevation deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("RelativeElevation deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngularOffsetFromRelatedObject()" ReturnType="Double"
		Description="Returns the angular offset for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getAngularOffsetFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getAngularOffsetFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("AngularOffset"),_warning, _info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("AngularOffset"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDirFromRelatedObject()" ReturnType="Double"
		Description="Returns the direction (Dir) from related object. Source object is an optional argument." >
		<Constructor>Double RC__getDirFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getDirFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Dir"),_warning, _info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Dir"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].Dir, _info("Direction (Dir) deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("Direction (Dir) deduced from object '"..RC__getNameOrCodeorId(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getWcsVectorFromAcsVector()" ReturnType="String"
		Description="Converts an Alignment Coordinate System (ACS) 2D vector into a World Coordinate System (WCS) 2D vector. Usage: wx,wy = RC__getWcsVectorFromAcsVector(lateralOffset,longitudinalOffset) or wx,wy = RC__getWcsVectorFromAcsVector(lateralOffset,longitudinalOffset,alongAxisWcsAngleInRadians)." >
		<Constructor>{Double,Double} RC__getWcsVectorFromAcsVector(lateralOffset,longitudinalOffset [,alongAxisWcsAngleInRadians = this.AlignmentTangent])</Constructor>
		<Formula>
			function RC__getWcsVectorFromAcsVector(acsX,acsY,alongAxisWcsAngleInRadians)
				--WCS = World Coordinate System, the CAD system's underlying absolute Cartesian coordinate system (XY-plane).
				--ACS = "Alignment Coordinate System", a basic RailCOMPLETE concept:
				--	Argument acsX = Lateral offset to the right, perpendicular to the object's alignment axis.
				--	Argument acsY = Along offset in the direction of increasing distAlong, along the object's alignment axis.
				--	Optional argument alongAxisWcsAngleInRadians = angle in Decimal Degrees between WCS East (X-axis) and the alignment's tangent direction.
				local angle
				if alongAxisWcsAngleInRadians then 
					angle = alongAxisWcsAngleInRadians
				else 
					angle = this.AlignmentTangent
				end
				return  acsX*math.sin(angle) + acsY*math.cos(angle), -acsX*math.cos(angle) + acsY*math.sin(angle)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getVectorModulus()" ReturnType="Double"
		Description="Returns the norm |u| of a 3D vector u" >
		<Constructor>Double RC__getVectorModulus(Point3D u)</Constructor>
		<Formula>
			function RC__getVectorModulus(u)
				return math.sqrt(u.X*u.X+ u.Y*u.Y + u.Z*u.Z)
			end
		</Formula>
	</LuaFunction>
			
	<LuaFunction Name="RC__getVectorScalarProduct()" ReturnType="Point3D"
		Description="Returns the scalar product mu of scalar m with 3D vector u" >
		<Constructor>Point3D RC__getVectorScalarProduct(Double m, Point3D u)</Constructor>
		<Formula>
			function RC__getVectorScalarProduct(m,u)
				return getPoint3D(m*u.X, m*u.Y, m*u.Z)
			end
		</Formula>
	</LuaFunction>
			
	<LuaFunction Name="RC__getVectorNormalized()" ReturnType="Point3D"
		Description="Returns a normalized non-zero 3D vector u/|u|" >
		<Constructor>Point3D RC__getVectorNormalized(Point3D u)</Constructor>
		<Formula>
			function RC__getVectorNormalized(u)
				m = 1/RC__getVectorModulus(u)
				return RC__getVectorScalarProduct(m,u)
			end
		</Formula>
	</LuaFunction>
			
	<LuaFunction Name="RC__getVectorSum()" ReturnType="Point3D"
		Description="Returns the sum u+v of two 3D vectors u,v" >
		<Constructor>Point3D RC__getVectorSum(Point3D u, Point3D v)</Constructor>
		<Formula>
			function RC__getVectorSum(u,v)
				return getPoint3D(u.X+v.X, u.Y+v.Y, u.Z+v.Z)
			end
		</Formula>
	</LuaFunction>
			
	<LuaFunction Name="RC__getVectorDifference()" ReturnType="Point3D"
		Description="Returns the subtraction u-v of two 3D vectors u,v" >
		<Constructor>Point3D RC__getVectorDifference(Point3D u, Point3D v)</Constructor>
		<Formula>
			function RC__getVectorDifference(u,v)
				return getPoint3D(u.X-v.X, u.Y-v.Y, u.Z-v.Z)
			end
		</Formula>
	</LuaFunction>
			
	<LuaFunction Name="RC__getVectorDotProduct()" ReturnType="Double"
		Description="Returns the dot product u.v of two 3D vectors u,v" >
		<Constructor>Double RC__getVectorDotProduct(Point3D u, Point3D v)</Constructor>
		<Formula>
			function RC__getVectorDotProduct(u,v)
				return u.X*v.X + u.Y*v.Y + u.Z*v.Z
			end
		</Formula>
	</LuaFunction>
			
	<LuaFunction Name="RC__getVectorCrossProduct()" ReturnType="Point3D"
		Description="Returns the cross product uxv of two 3D vectors u,v" >
		<Constructor>Point3D RC__getVectorCrossProduct(Point3D u, Point3D v)</Constructor>
		<Formula>
			function RC__getVectorCrossProduct(u,v)
				return getPoint3D((u.Y*v.Z - u.Z*v.Y), -(u.X*v.Z - u.Z*v.X), (u.X*v.Y - u.Y*v.X))
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getVectorAngleCosSin()" ReturnType="{Double,Double}"
		Description="Returns cosa,sina where cosa = u.v/|u||v| and sina = |uxv|/|u||v| (0..180 degrees)" >
		<Constructor>{Double,Double} RC__getVectorAngleCosSin(Point3D u, Point3D v)</Constructor>
		<Formula>
			function RC__getVectorAngleCosSin(u,v)
				d = RC__getVectorModulus(u) * RC__getVectorModulus(v)
				cos = RC__getVectorDotProduct(u,v)/d
				sin = RC__getVectorModulus(RC__getVectorCrossProduct(u,v))/d
				return cos,sin
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getVectorAngleDD()" ReturnType="Double"
		Description="Returns the unsigned angle [Decimal Degrees] between 3D vector u and 3D vector v (0..180 degrees)" >
		<Constructor>Double RC__getVectorAngleDD(Point3D u, Point3D v)</Constructor>
		<Formula>
			function RC__getVectorAngleDD(u,v)
				cc,ss = RC__getVectorAngleCosSin(u,v)
				return math.deg(math.atan(ss,cc))
			end
		</Formula>
	</LuaFunction>


			
	<LuaFunction Name="RC__getNameOrCodeorId()" ReturnType="String"
		Description="Returns the object's name if non-empty, or its code if non-empty, otherwise returns its ID. Addresses the calling object if no object reference is given." >
		<Constructor>String RC__getNameOrCodeorId([Reference obj])</Constructor>
		<Formula>
			function RC__getNameOrCodeorId(obj)
				obj = obj or this
				if type(obj) ~= "table" then
					return "ERROR: RC__getNameOrCodeorId() called with a bad argument type '"..type(obj).."', an objRef was expected ***"
				end
				objName = obj:getPropertyValue("name")
				objCode = obj:getPropertyValue("code")
				objId = obj:getPropertyValue("id")
				if objName ~= nil and objName ~= "" then return objName
				elseif objCode ~= nil and objCode  ~= "" then return objCode
				else return tostring(objId)
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isNan()" ReturnType="Bool"
		Description="Returns true if input value is NaN (not a number), otherwise returns false." >
		<Constructor>Bool RC__isNan(Double value)</Constructor>
		<Formula>function RC__isNan(x) return x ~= x end</Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getUrlExtension()" ReturnType="String"
		Description="Returns filename extension (file type). Default url is the current document." >
		<Constructor>String RC__getUrlExtension([String url])</Constructor>
		<Formula>
			function RC__getUrlExtension(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[%.]([^%.]-)$") -- Extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDriveAndFolderAndFilename()" ReturnType="String"
		Description="Returns drive letter, folder name and file name. Default url is the current document." >
		<Constructor>String RC__getUrlDriveAndFolderAndFilename([String url])</Constructor>
		<Formula>
			function RC__getUrlDriveAndFolderAndFilename(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[%.][^%.]-$") -- Drive letter, folder and filename without extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDriveAndFolder()" ReturnType="String"
		Description="Returns drive letter and folder name. Default url is the current document." >
		<Constructor>String RC__getUrlDriveAndFolder([String url])</Constructor>
		<Formula>
			function RC__getUrlDriveAndFolder(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[\\/][^\\/]-$") -- Drive letter and folder name
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDrive()" ReturnType="String"
		Description="Returns drive letter. Default url is the current document." >
		<Constructor>String RC__getUrlDrive([String url])</Constructor>
		<Formula>
			function RC__getUrlDrive(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[:][^:]-$") -- Drive letter(s)
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlFilename()" ReturnType="String"
		Description="Returns filename without extension. Default url is the current document." >
		<Constructor>String RC__getUrlFilename([String url])</Constructor>
		<Formula>
			function RC__getUrlFilename(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[\\/]?([^\\/]-)[%.][^%.]-$") -- Filename without extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlFilenameAndExtension()" ReturnType="String"
		Description="Returns filename with extension. Default url is the current document." >
		<Constructor>String RC__getUrlFilenameAndExtension([String url])</Constructor>
		<Formula>
			function RC__getUrlFilenameAndExtension(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[\\/]?([^\\/]-)$") -- Filename and extension
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getRound()" ReturnType="String"
		Description="Rounds floating point input x to p [-6..6] decimal places. Default precision is 0 decimals." >
		<Constructor>Double RC__getRound(Double x [, Int p])</Constructor>
		<Formula>
			function RC__getRound(x,p) 
				if math.abs(x) == math.huge then return x end --plus/minus Inf
				if p == nil then p = 0 end
				p = math.floor(p)
				if p &lt; -6 or p &gt; 6 then
					return "Precision ["..p.."] must be from -6 to 6, cannot format value ["..x.."]",_warning
				elseif p == 6 then x = string.format("%.6f",math.floor((x+0.5*1e-6)*1e6)/1e6)
				elseif p == 5 then x = string.format("%.5f",math.floor((x+0.5*1e-5)*1e5)/1e5) 
				elseif p == 4 then x = string.format("%.4f",math.floor((x+0.5*1e-4)*1e4)/1e4) 
				elseif p == 3 then x = string.format("%.3f",math.floor((x+0.5*1e-3)*1e3)/1e3) 
				elseif p == 2 then x = string.format("%.2f",math.floor((x+0.5*1e-2)*1e2)/1e2) 
				elseif p == 1 then x = string.format("%.1f",math.floor((x+0.5*1e-1)*1e1)/1e1) 
				elseif p == 0 then x = string.format("%d",math.floor((x+0.5*1e0)*1e0)/1e0)
				elseif p == -1 then x = string.format("%d",math.floor((x+0.5*1e1)*1e-1)/1e-1) 
				elseif p == -2 then x = string.format("%d",math.floor((x+0.5*1e2)*1e-2)/1e-2)
				elseif p == -3 then x = string.format("%d",math.floor((x+0.5*1e3)*1e-3)/1e-3)
				elseif p == -4 then x = string.format("%d",math.floor((x+0.5*1e4)*1e-4)/1e-4)
				elseif p == -5 then x = string.format("%d",math.floor((x+0.5*1e5)*1e-5)/1e-5)
				elseif p == -6 then x = string.format("%d",math.floor((x+0.5*1e6)*1e-6)/1e-6)
				end
				return tonumber(x)
			end
        </Formula>
	</LuaFunction>

  
  
	<LuaFunction Name="RC__getSnap()" ReturnType="String"
		Description="Returns nearest multiple of step size. Default step size is 3. E.g., '4.51' => '6' and '-7.49' => '-6'." >
		<Constructor>Double RC__getSnap(Double x [, Double stepSize])</Constructor>
		<Formula>
			function RC__getSnap(x,stepSize) 
				if stepSize == nil then 
					if x == nil then
						return 0,_warning
					else
						stepSize = 3
					end
				end
				stepSize = math.floor(math.abs(stepSize))
				if stepSize == 0 then
					return 0
				else
					return stepSize * math.floor((x / stepSize) + 0.5)
				end
			end
		</Formula>
	</LuaFunction>



	<!-- TODO  2022-04-21 CLFEY -->
	    <!-- The present 3D sweep needs to "jump" from point to point and will stop short of the underlying gradient curve's -->
	<!-- end before all of it has been sweeped. If the very last sweep step size does not extend the sweep to the end of the gradient curve, -->
	<!-- then the last part will not be shown in 3D.  -->
	    <!-- This behaviour has been amended in Eirik Hovind's work on 3D issues (2021-2022), making this RC__getNearest3DStep() function  -->
	<!-- obsolete. ==> That is, the function RC__getNearest3DStep() shall be deprecated as soon as all users have upgraded their RC software version. -->
	<LuaFunction Name="RC__getNearest3DStep()" ReturnType="Double"
		Description="Returns the nearest step value larger then the given argument (default is 10) which results in a complete 3D sweep of an alignment to ensure that the last sampled point is at the end of the alignment." >
		<Constructor>Double RC__getNearest3DStep(step) </Constructor>
		<Formula>
			function RC__getNearest3DStep(step)
				if step == nil then step = 10 end
				local a = RcAlignment
				-- is the caller an alignment?
				if a == nil then return step end
				local L = a.HorizontalProfile.Length
				if step &lt;= 0 or step &gt;= L then 
					return (L - 1e-3)
				else
					N = math.floor(L/step)
					return L/N - 1e-4
					--Note: if N gets very large then there might be a noticeable "missing link" at the end of the alignment
				end 
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isMemberOf()" ReturnType="Boolean" 
		Description="Returns true if table/collection/dictionary contains item. The item may be part of a numbered Lua sequence {2,3,5,7,11} or a value in a key/value pair {x=1,y=1,z=2,t=3,u=5}. Advice: When looking for objects, look for its id property item.id (a text string) rather than an object reference, as objects may be relocated in memory for each Lua execution." >
		<Constructor>Boolean RC__isMemberOf(Table t, Item item)</Constructor>
		<Formula>
			function RC__isMemberOf(t,item) 
				local i
				if getTableValue(t) == nil and type(t) == "table" then
					-- A genuine Lua table, convert it to RailCOMPLETE/C# collection object (deleting the keys from key/value pairs):
					t = getCollectionFromTable(t)
					--Collections respond correctly to the '.count' attribute:
					for i = 0, t.count-1 do
						if type(item) == "string" or type(item) == "number" then
							if t[i] == item then
								return true
							end
						elseif item.id then
							if t[i] == item.id then
								return true
							end
						end
					end
				end
				return false
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__sortTable()" ReturnType="Table"
		Description="Returns a sorted table (indexed 1,2,...)." >
		<Constructor>table RC__sortTable(table t)</Constructor>
		<Formula>
			function RC__sortTable(t)
				local u,v,n,i,j,k,lo
				if t == nil then return nil,_error end
				if type(t) ~= type({}) then return '***',_warning end
				--Insertion sort, ok for small tables. TODO: Implement QuickSort for larger tables.
				u = {}
				v = {}
				n = 0
				while t[n+1] do
					n = n + 1
					table.insert(u,t[n])
				end		
				for i = 1, n do
					lo = math.huge
					for j = 1, n-i+1 do
						if u[j] &lt; lo then 
							lo = u[j]
							k = j 
						end
					end
					table.insert(v,table.remove(u,k)) --insert smallest number from u into v
				end
				return v
			end 
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__toKm()" ReturnType="String"
		Description="Converts input x [m] into mileage [km] with precision p (0..6), default precision is 3. E.g., 462371.637 => 462.372." >
		<Constructor>Double RC__toKm(Double x [, Int p])</Constructor>
		<Formula>
			function RC__toKm(x,p) 
				if p == nil then 
					if x == nil then
						return 0.0,_warning
					else
						p = 3
					end
				end
				p = math.floor(math.abs(p))
				if p &lt; 0 or p &gt; 6 then
					return "Precision ["..p.."] must be from 0 to 6, cannot format value ["..x.."]",_warning
				elseif p == 0 then return string.format("%.0f",math.floor((x+0.5*1e3)*1e-3)/1e0)
				elseif p == 1 then return string.format("%.1f",math.floor((x+0.5*1e2)*1e-2)/1e1)
				elseif p == 2 then return string.format("%.2f",math.floor((x+0.5*1e1)*1e-1)/1e2) 
				elseif p == 3 then return string.format("%.3f",math.floor((x+0.5*1e0)*1e0)/1e3)
				elseif p == 4 then return string.format("%.4f",math.floor((x+0.5*1e-1)*1e1)/1e4) 
				elseif p == 5 then return string.format("%.5f",math.floor((x+0.5*1e-2)*1e2)/1e5) 
				elseif p == 6 then return string.format("%.6f",math.floor((x+0.5*1e-3)*1e3)/1e6) 
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__getDistance2D()" ReturnType="Double"
		Description="Returns the Euclidian distance in the XY plane between inputs p1 and p2 (point objects or Point3D), each being geoCoord or table {['X']=x,['Y']=y}. p2 is by default the calling object. Z's are ignored." >
		<Constructor>Double RC__getDistance2D(Point p1 [,Point p2])</Constructor>
		<Formula>
			function RC__getDistance2D(p1,p2) 
				local x1,x2,y1,y2
				if p1 == nil then 
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					--Ordinary RailwayPlacedObject:
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
				elseif p1.X then 
					--Point3D:
					x1 = p1.X
					y1 = p1.Y
				else
					return 0,_warning, _info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					--Ordinary RailwayPlacedObject:
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
				elseif p2.X then
					--Point3D:
					x2 = p2.X
					y2 = p2.Y
				else
					return 0,_warning, _info("Second point has no X coordinate.")
				end
				return math.sqrt(math.pow(x2-x1,2) + math.pow(y2-y1,2))
			end
        </Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getDistance3D()" ReturnType="Double"
		Description="Returns the Euclidian distance in XYZ space between inputs p1 and p2 (point objects or Point3D), each being geoCoord or table {['X']=x,['Y']=y,['Z']=z}. p2 is by default the calling object. Z's are 0 if missing." >
		<Constructor>Double RC__getDistance3D(Point p1 [,Point p2])</Constructor>
		<Formula>
			function RC__getDistance3D(p1,p2) 
				local x1,x2,y1,y2,z1,z2
				-- This code will work both for railML geoCoord entities and for tables using "X", "Y" and "Z" as indices. 
				if p1 == nil then
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
					z1 = p1.geoCoord.Z
				elseif p1.X then 
					x1 = p1.X
					y1 = p1.Y
					z1 = p1.Z == nil and 0 or p1.Z
				else
					return 0,_warning, _info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
					z2 = p2.geoCoord.Z
				elseif p2.X then 
					x2 = p2.X
					y2 = p2.Y
					z2 = p2.Z == nil and 0 or p2.Z
				else
					return 0,_warning, _info("Second point has no X coordinate.")
				end
				return math.sqrt(math.pow(x2-x1,2) + math.pow(y2-y1,2) + math.pow(z2-z1,2))
			end
        </Formula>
	</LuaFunction>


	
<!--========================================================================================================
    RC common Lua, general but still railway-specific issues, present in any railway administration
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
	<LuaFunction Name="RC_com_getNearestEntireKm()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when also half km is to be shown, e.g., 461.749 => 461 (half km is 5) and 461.750 => 462 (half km is 0)." >
		<Constructor>Int RC_com_getNearestEntireKm([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestEntireKm(obj)
				obj = obj or this
				return math.floor(math.floor((obj:getPropertyValue("ReferenceMileage")/500)+.5)/2)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getNearestEntireKm2()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when the half km is not to be shown, e.g., 461.499 => 461 and 461.500 => 462." >
		<Constructor>Int RC_com_getNearestEntireKm2([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestEntireKm2(obj)
				obj = obj or this
				return math.floor(math.floor(obj:getPropertyValue("ReferenceMileage")/1000 + 0.5))
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getNearestHalfKm()" ReturnType="String"
		Description="Returns object's reference mileage's half km (0 or 5), e.g., 461.750 => 0 (whole km is 461) and 462.372 => 5 (whole km is 462)." >
		<Constructor>Int RC_com_getNearestHalfKm([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestHalfKm(obj)
				obj = obj or this
				return (math.floor((obj.ReferenceMileage/500)+0.5)%2)*5
			end
		</Formula>
	</LuaFunction>
	
	
	
	<LuaFunction Name="RC_com_getNearestHectometricSnap()" ReturnType="String"
		Description="Returns object's reference mileage's nearest whole hectometer." >
		<Constructor>Int RC_com_getNearestHectometricSnap([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestHectometricSnap(obj)
				obj = obj or this
				return 100 * ((50 + obj:getPropertyValue("ReferenceMileage")) // 100)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getNearestKilometricSnap()" ReturnType="String"
		Description="Returns object's reference mileage's nearest whole kilometer." >
		<Constructor>Int RC_com_getNearestKilometricSnap([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestKilometricSnap(obj)
				obj = obj or this
				return 1000 * ((500 + obj:getPropertyValue("ReferenceMileage")) // 1000)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getLabelItem1()" ReturnType="String"
		Description="Returns the ReferenceMileage, formated as Km.&lt;value&gt;, for the label's own insertion point." >
		<Constructor>String RC_com_getLabelItem1()</Constructor>
		<Formula>
			function RC_com_getLabelItem1()
				return "Km."..RC__toKm(referenceMileage,3)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getLabelItem2()" ReturnType="String"
		Description="Returns a list consisting of the Code for each item related to the label (labels can relate to anything)." >
		<Constructor>String RC_com_getLabelItem2()</Constructor>
		<Formula>
			function RC_com_getLabelItem2()
				local r,n,s,i
				s = "Er etikett for anything"
				r,n = RC__getCollectionOfRelatedObjects(s)
				if n == 0 then 
					return "UNFINISHED - Relate with '"..s.."'."
				else
					t = "("..r[0].code
					for i = 1, n-1 do
						t = t..", "..r[i].code
					end
					return t..")"
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getLabelItem3()" ReturnType="String"
		Description="Returns the reference alignment Code for the label itself (not for a related item)." >
		<Constructor>String RC_com_getLabelItem3()</Constructor>
		<Formula>
			function RC_com_getLabelItem3()
				return "(Ref. "..referenceAlignment.code..")"
			end
		</Formula>
	</LuaFunction>



    <LuaFunction Name="RC_com_getAreasOfVariant()" ReturnType="Collection of RcArea"
		Description="Returns a count and a collection of visible areas of the given variant, enclosing the object." >
        <Constructor>Int, Collection of RcArea RC_com_getAreasOfVariant(String areaVariantName [, String guidString])</Constructor>
        <Formula>
			function RC_com_getAreasOfVariant(areaVariantName, guidString)
				local obj = guidString and getObjectFromId(guidString) or this
				local areas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:match(areaVariantName) end)
				return areas.count,areas
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
	The old railML property 'ocpStationRef' has been set to Browsable = false in C#, to HIDE IT from users.
	Do NOT try to assign values to it (this is possible even if it does not show up in RC-ManageProperties).
	Instead, use our own ocpStationReference property, which expects a string.
=========================================================================================================-->
		<!-- <xpp:expand select="RC_com_SET_OCP_STATION_REFERENCE" /> -->
<xpp:define name="RC_com_SET_OCP_STATION_REFERENCE" >
	<xpp:bloc>
		<LuaExpression Name="ocpStationReference" ><Formula>RC_com_getOcpStationReference()</Formula></LuaExpression>
	</xpp:bloc>
</xpp:define>

    <LuaFunction Name="RC_com_getOcpStationReference()" ReturnType="ObjRef"
		Description="Returns an object reference for the current Operation Control Point (OCP) area, or nil if not contained in any (visible) OCP area." >
        <Constructor>ObjRef RC_com_getOcpStationReference()</Constructor>
		<Formula>
			function RC_com_getOcpStationReference()
				local OcpAreas = RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				return getCollectionLength(OcpAreas) == 0 and "" or OcpAreas[0] --a GUID string.
			end
        </Formula>
    </LuaFunction>
	
	<LuaFunction Name="RC_com_getOcpStationRef()" ReturnType="ObjRef" 
	Description="Included for backwards compatilbility. Calls RC_com_getOcpStationReference(), which returns an ObjRef and not a GUID string as mandataed by railML." HideFromUser="false" >
		<Constructor>ObjRef RC_com_getOcpStationRef()</Constructor>
		<Formula>
			function RC_com_getOcpStationRef()
				return RC_com_getOcpStationReference()
			end
       </Formula>
	</LuaFunction>



	<LuaFunction Name="RC_com_getOcpCode()" ReturnType="String"
		Description="Returns the code property for the Operation / Control Point (OCP) area surrounding the object." >
        <Constructor>String RC_com_getOcpCode([Reference obj])</Constructor>
		<Formula>
			function RC_com_getOcpCode(obj)
				local OcpAreas,n
				obj = obj or this
				local OcpAreas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				n = getCollectionLength(OcpAreas)
				if n == 0 then 
					return "(UNFINISHED - No 'OCP område' area enclosing object.)"
				elseif n == 1 then
					return OcpAreas[0].code
				else
					return "WARNING - Multiple 'OCP område' areas enclosing object ["..RC__getNameOrCodeorId(OcpAreas[0])..", "..RC__getNameOrCodeorId(OcpAreas[1]).." ...]."
				end
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
    RC discpline-dependent Lua, but present in any railway administration
=========================================================================================================-->
<!--========================================================================================================
	Signaling
=========================================================================================================-->
 

	
<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>
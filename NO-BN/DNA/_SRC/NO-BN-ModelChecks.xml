<!--========================================================================================================

    NO-BN-ModelChecks.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml" />.

	(c) Railcomplete AS, Norway, 2015-2021. All rights reserved.
	
=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
    Common
=========================================================================================================-->
	<!-- <xpp:expand select="NOBN_com_CHK_NUMBER_OF_OCP_AREAS" /> -->
<xpp:define name="NOBN_com_CHK_NUMBER_OF_OCP_AREAS" >
	<xpp:bloc>
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_NumberOfOcpAreas" DisplayName="Antall OCP områder" 
			Description="Number of Operation / Control Point (OCP) areas to which the object belongs. Most objects shall belong to an OCP, holding properties such as location name and/or resource names." />
		<LuaExpression Name="mc_NumberOfOcpAreas" IsModelCheck="true" >
			<Formula>NOBN_com_chkNumberOfOcpAreas()</Formula>
		</LuaExpression>
	</xpp:bloc>
</xpp:define>

<xpp:define name="NOBN_com_CHK_CONNECTION___CONTINUATION" >
	<xpp:bloc>
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_AlignmentType" DisplayName="Alignment type" Description="The alignments must be compatible." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Continuity" DisplayName="Continuity" Description="The alignments shall end in the same XY point (seen from the above)." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Tangent" DisplayName="Tangent direction" Description="The alignments shall share the same tangent (i.e., XY-plane differentiability)." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Elevation" DisplayName="Elevation" Description="The alignments shall share the same elevation (Z-coordinate)." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Gradient" DisplayName="Gradient" Description="The alignments shall share the same gradient (pitch [o/oo])." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Cant" DisplayName="Cant" Description="The alignments shall share the same cant (roll / superelevation [mm]) where they meet." />
		<LuaExpression Name="mc_AlignmentType" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionAlignmentCompatibility()</Formula></LuaExpression>
		<LuaExpression Name="mc_Continuity" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionContinuity()</Formula></LuaExpression>
		<LuaExpression Name="mc_Tangent" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionTangentMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Elevation" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionElevationMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Gradient" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionGradientMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Cant" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionCantMatch()</Formula></LuaExpression>
	</xpp:bloc>
</xpp:define>



    <LuaFunction Name="NOBN_com_chkNumberOfOcpAreas()" ReturnType="String"
		Description = "Model check assessing the number of (visible) Operation / Control Point (OCP) areas that the object belongs to." >
        <Constructor>String NOBN_com_chkNumberOfOcpAreas()</Constructor>
        <Formula>
			function NOBN_com_chkNumberOfOcpAreas()
				areas = RcArea:filter(function(x) return x.RcType == "JBTFE_DIV OCP område" end)
				if (areas.Count == 0) then
					--TODO: Return the '_unfinished' symbol, but remove this check from objects that do not need it (a NOBN_com_CHK_NUMBER_OF_OCP_AREAS macro):
					return "0: UNFINISHED - Object does not belong to any Operation / Control area (OCP). Create an Rc-Area of type 'OCP' around the object."
					-- NB: Leave it to the object's own SymbolFrame formula to define whether a 'Unfinished' frame should be shown or not
				elseif (areas.Count == 1) then 
					return _ok,areas[0].code..": OK - Object belongs to just one Operation / Control (OCP) area."
				else 
					return _warning,areas.Count..": WARNING - Object belongs to several Operation / Control (OCP) areas."
				end
			end
        </Formula>
    </LuaFunction> 


	<LuaFunction Name="NOBN_com_chkConnectionAlignmentCompatibility()" ReturnType="String"
		Description="Checks that own alignment type and target alignment type are compatible at a connection." >
		<Constructor>String NOBN_com_chkConnectionAlignmentCompatibility()</Constructor>
		<Formula>
			function NOBN_com_chkConnectionAlignmentCompatibility()
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				if RcType == "JBTEH_ISO Lineisolator" then
					compatibility = { 
						{ a="Kontaktledning, avspenningsline", ta={"Kontaktledning, kjørbar", "Kontaktledning, ikke kjørbar", "Kontaktledning, avspenningsline", "-"}},
						{ a="Kontaktledning, kjørbar", ta={"Kontaktledning, avspenningsline"}},
						{ a="Kontaktledning, ikke kjørbar", ta={"Kontaktledning, avspenningsline"}},
						{ a="Fixline", ta={"Fixline","-"}},
						{ a="Bardun", ta={"Bardun","-"}}
					}
					v1 = Alignment.Variant
					v2 = TargetAlignment and TargetAlignment.Variant or "-"
					for i = 1,5 do
						if compatibility[i].a == v1 then
							if RC__isMemberOf(compatibility[i].ta,v2) then
								return v1.."/"..v2..": OK - Alignment types and variants are compatible ",_ok
							end
						end
					end
					return v1.."/"..v2..": ERROR - Incompatible adjacent alignment types / variants.",_error
				else
					if TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end
					if TargetAlignment and Alignment.id == TargetAlignment.id then 
						return Alignment.RcType.."/"..TargetAlignment.RcType..": ERROR - Target alignment object is same as own alignment object.",_error
					end
					if TargetAlignment.RcType ~= Alignment.RcType then
						return Alignment.RcType.."/"..TargetAlignment.RcType..": ERROR - Target alignment type must be same as own alignment type ("..Alignment.RcType..").",_error
					else
						return Alignment.RcType.."/"..TargetAlignment.RcType..": OK - Alignment types are compatible.",_ok
					end
				end
			end
		</Formula>
	</LuaFunction>
	
	<LuaFunction Name="NOBN_com_chkConnectionContinuity()" ReturnType="String"
		Description="Checks that alignments are well-positioned where they meet (in the XY-plane)." >
		<Constructor>String NOBN_com_chkConnectionContinuity()</Constructor>
		<Formula>
			function NOBN_com_chkConnectionContinuity()
				tol = 0.030 -- meter
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				if RcType ~= "JBTEH_ISO Lineisolator" and TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end

				if RcType == "JBTEH_ISO Lineisolator" then 
					if TargetAlignment == nil then
						return "-: OK – Object does not act as a connection (being too far from any potential target alignment).",_ok
					elseif TargetAlignment and Alignment.id == TargetAlignment.id then 
						return "-: OK - This object type accepts that target alignment is same as own alignment.",_ok
					else
						if ExtendingFromEnd then 
							p1 = Alignment.RcAlignment.EndPoint
						else
							p1 = Alignment.RcAlignment.StartPoint
						end 
						if ContinuingWithBegin then
							p2 = TargetAlignment.RcAlignment.StartPoint
						else 
							p2 = TargetAlignment.RcAlignment.EndPoint
						end
						delta = RC__getDistance2D(p1,p2)
					end

				elseif RcType == "JBTKO_SPF Sporfortsettelse" or RcType == "JBTEH_LEF Ledningfortsettelse" or RcType == "JBTEH_KTF Kontaktledningfortsettelse" then 
					if ExtendingFromEnd then 
						p1 = Alignment.RcAlignment.EndPoint
					else
						p1 = Alignment.RcAlignment.StartPoint
					end 
					if ContinuingWithBegin then
						p2 = TargetAlignment.RcAlignment.StartPoint
					else 
						p2 = TargetAlignment.RcAlignment.EndPoint
					end
					delta = RC__getDistance2D(p1,p2)

				elseif RcType == "JBTKO_SPV Sporveksel" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					p1 = getAlignmentInfo().Point --Projection of stock rail joint onto own alignment (2D)
					d1 = RC__getDistance2D(p1,TargetAlignment.RcAlignment.StartPoint)
					d2 = RC__getDistance2D(p1,TargetAlignment.RcAlignment.EndPoint)
					delta = d1 &lt; d2 and d1 or d2

				elseif RcType == "JBTKO_SPV Sporkryss" then
					-- Check that both alignments pass, i.e. none of them should have a continuation exactly at the crossing's position
					if not getAlignmentInfo(Alignment.id).NormalProjectionExists then
						return "ERROR: Crossing is outside Own Alignment - move crossing or extend own alignment.",_error
					elseif not getAlignmentInfo(TargetAlignment.id).NormalProjectionExists then
						return "ERROR: Crossing is outside Target Alignment - move crossing or extend target alignment.",_error
					else
						delta = RC__getDistance2D(getAlignmentInfo().Point.getAlignmentInfo(TargetAlignment.id).Point) --p projection (in XY-plane) onto both alignments
						if (delta &lt; tol/2) then
							return string.format("%.03f",delta) .. ": OK – Crossing is close to both alignments where they cross, within 50% of tolerance " .. string.format("%.03f", tol).." m.",_ok
						elseif (delta &lt; tol) then
							return string.format("%.03f",delta) .. ": WARNING – Crossing should be moved closer to where alignments cross, but is still within tolerance " .. string.format("%.03f", tol).." m.",_warning
						else
							return string.format("%.03f",delta) .. ": ERRROR – Crossing is placed too far away from where alignments cross, outside tolerance " .. string.format("%.03f", tol).." m.",_error
						end
					end

				else
					return RcType..": ERROR - Bad connection object type",_error
				end
				if (delta &lt; tol/2) then return string.format("%.03f",delta) .. ": OK – Alignments meet at connection within 50% of tolerance " .. string.format("%.03f", tol).." m.",_ok
				elseif (delta &lt; tol) then return string.format("%.03f",delta) .. ": WARNING – Alignments should be closer at connection, but are still within tolerance " .. string.format("%.03f", tol).." m.",_warning
				else return string.format("%.03f",delta) .. ": ERROR: Alignments are too far apart at connection, outside tolerance " .. string.format("%.03f", tol).." m.",_error end
			end
		</Formula>
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_com_chkConnectionTangentMatch()" ReturnType="String"
		Description="Checks that alignment tangents (directions) match where they meet (in the XY-plane)." >
		<Constructor>String NOBN_com_chkConnectionTangentMatch()</Constructor>
		<Formula>
			function NOBN_com_chkConnectionTangentMatch()
				tol = 1.0  -- decimal degrees (Deutsche Bahn allegedly allows 1 degree in discontinuities)
				maxNumber = 20 -- 2:(maxNumber*2) is the steepest crossing that we will classify as a crossing and not as an engineering error
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				if RcType ~= "JBTEH_ISO Lineisolator" and TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end

				if RcType == "JBTEH_ISO Lineisolator" and TargetAlignment == nil then
						return "-: OK – Object does not act as a connection (being too far from any potential target alignment).",_ok
			
				elseif RcType == "JBTKO_SPF Sporfortsettelse" 
				or RcType == "JBTEH_LEF Ledningfortsettelse" 
				or RcType == "JBTEH_KTF Kontaktledningfortsettelse" 
				or RcType == "JBTEH_ISO Lineisolator"
				then
					if ExtendingFromEnd then 
						t1 = Alignment.RcAlignment.HorizontalProfile.EndDir * (180/math.pi)
					else
						t1 = Alignment.RcAlignment.HorizontalProfile.Segments[0].StartDir * (180/math.pi)
					end 
					if ContinuingWithBegin then
						t2 = TargetAlignment.RcAlignment.HorizontalProfile.Segments[0].StartDir * (180/math.pi)
					else
						t2 = TargetAlignment.RcAlignment.HorizontalProfile.EndDir * (180/math.pi)
					end
					delta = ((90 + t2 - t1) % 180) - 90 --decimal degrees difference (alignments may be counterdirected)
					if (math.abs(delta) &lt; tol / 2) then return string.format("%.03f",delta) .. ": OK - Tangents match within 50% of tolerance +/- " .. string.format("%.03f", tol).." degrees.",_ok
					elseif (math.abs(delta) &lt; tol) then return string.format("%.03f",delta) .. ": WARNING – Tangents match, but close to tolerance +/- " ..
							string.format("%.03f", tol).." degrees.",_warning
					else return string.format("%.03f",delta) .. ": ERROR – Tangents are too different, outside tolerance +/- " .. string.format("%.03f", tol).." degrees.",_error
					end
			
				elseif RcType == "JBTKO_SPV Sporveksel" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					p1 = getAlignmentInfo().Point --Projection of stock rail joint onto own alignment (2D)
					d1 = RC__getDistance2D(p1,TargetAlignment.RcAlignment.StartPoint)
					d2 = RC__getDistance2D(p1,TargetAlignment.RcAlignment.EndPoint)
					t1 = math.atan(getAlignmentInfo().Tangent.Y, getAlignmentInfo().Tangent.X) * (180/math.pi) -- Can disregard Tangent.Z here, since only relative zize Y:X matters
					if d1 &lt; d2 then
						t2 = TargetAlignment.RcAlignment.HorizontalProfile.StartDir * (180/math.pi)
					else
						t2 = TargetAlignment.RcAlignment.HorizontalProfile.EndDir * (180/math.pi)
					end
					delta = ((90 + t2 - t1) % 180) - 90 --decimal degrees difference (alignments may be counterdirected)
					if (math.abs(delta) &lt; tol / 2) then return string.format("%.03f",delta) .. ": OK - Tangents match within 50% of tolerance +/- " .. string.format("%.03f", tol).." degrees.",_ok
					elseif (math.abs(delta) &lt; tol) then return string.format("%.03f",delta) .. ": WARNING – Tangents match, but close to tolerance +/- " ..
							string.format("%.03f", tol).." degrees.",_warning
					else return string.format("%.03f",delta) .. ": ERROR – Tangents are too different, outside tolerance +/- " .. string.format("%.03f", tol).." degrees.",_error
					end
			
				elseif RcType == "JBTKO_SPV Sporkryss" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					if not getAlignmentInfo(TargetAlignment.id).NormalProjectionExists then
						return TargetAlignment.code..": WARNING - Connection object has no projection onto its target alignment (cannot compute mileage).",_warning
					end
					-- Can disregard Tangent.Z here, since only relative size Y:X matters:
					t1 = math.atan(getAlignmentInfo().Tangent.Y, getAlignmentInfo().Tangent.X) * (180/math.pi)
					t2 = math.atan(getAlignmentInfo(TargetAlignment.id).Tangent.Y, getAlignmentInfo(TargetAlignment.id).Tangent.X) * (180/math.pi)
			
					x_1_9 = (180/math.pi) * math.atan(1/9) -- Single or double slip 1:9 point
					x_1_12 = (180/math.pi) * math.atan(1/12) -- Single or double slip 1:12 point
					x_2_9 = 2.0 * (180/math.pi) * math.atan(1/9) -- Crossing between four 1:9 switches in parallel tracks
					x_2_12 = 2.0 *(180/math.pi) * math.atan(1/12) -- Crossing between four 1:12 switches in parallel tracks
			
					delta = math.abs(((90 + t2 - t1) % 180) - 90) --decimal degrees difference (alignments may be counterdirected)
					d_1_9 = delta - x_1_9
					d_1_12 = delta - x_1_12
					d_2_9 = delta - x_2_9
					d_2_12 = delta - x_2_12
					crossingNumber = 1/math.tan(math.abs(delta*(math.pi/180))) --Add the angles between each track to the centerline between the tracks
				
					-- If angle is close to 1:9 or 1:12 then the crossing is probably part of an Englishman (EKW, DKW), and not a crossing:
					if math.abs(d_1_12) &lt; tol then 
						if math.abs(d_1_12) &lt; (tol / 2) then 
							return string.format("%.03f (1:%.03f): OK - Crossing tangents match 1:12 within 50%% of tolerance +/- %.03f degrees.", 
								d_1_12, 1/math.tan(delta*(math.pi/180)), tol),_ok
						else 
							return string.format("%.03f (1:%.03f): WARNING – Crossing tangents match 1:12, but close to tolerance +/- %.03f degrees.", 
								d_1_12, 1/math.tan(delta*(math.pi/180)), tol),_warning
						end
					elseif math.abs(d_1_9) &lt; tol then 
						if math.abs(d_1_9) &lt; (tol / 2) then 
							return string.format("%.03f (1:%.03f): OK - Crossing tangents match 1:9 within 50%% of tolerance +/- %.03f degrees.",
								d_1_9, 1/math.tan(delta*(math.pi/180)), tol),_ok
						else 
							return string.format("%.03f (1:%.03f): WARNING – Crossing tangents match 1:9, but close to tolerance +/- %.03f degrees.",
								d_1_9, 1/math.tan(delta*(math.pi/180)), tol),_warning
						end
			
					-- A standard crossing matches two symmetrical pairs of 1:9 or 1:12 switches (here called '2_9' and '2_12'):
					elseif math.abs(d_2_12) &lt; tol then 
						if math.abs(d_2_12) &lt; (tol / 2) then 
							return string.format("%.03f (2:%.03f): OK - Crossing tangents match 2:12 within 50%% of tolerance +/- %.03f degrees.", 
								d_2_12, 1/math.tan((delta/2)*(math.pi/180)), tol),_ok
						else 
							return string.format("%.03f (2:%.03f): WARNING – Crossing tangents match 2:12, but close to tolerance +/- %.03f degrees.", 
								d_2_12, 1/math.tan((delta/2)*(math.pi/180)), tol),_warning
						end
					elseif math.abs(d_2_9) &lt; tol then 
						if math.abs(d_2_9) &lt; (tol / 2) then 
							return string.format("%.03f (2:%.03f): OK - Crossing tangents match 2:9 within 50%% of tolerance +/- %.03f degrees.",
								d_2_9, 1/math.tan((delta/2)*(math.pi/180)), tol),_ok
						else 
							return string.format("%.03f (2:%.03f): WARNING – Crossing tangents match 2:9, but close to tolerance +/- %.03f degrees.",
								d_2_9, 1/math.tan((delta/2)*(math.pi/180)), tol),_warning
						end
			
					elseif crossingNumber &gt;= maxNumber then 
						return string.format("%.03f (1:%.01f): ERROR - Crossing tangents are close to being parallel, check for engineering or measurement errors.",
								delta, crossingNumber),_error
			
					else
						return string.format("%.03f (1:%.01f): WARNING – Crossing tangents do not fit 1:9, 1:12, 2:9 or 2:12 (single slip / double slip / 4 switches) within tolerance %.03f degrees", 
								delta, 1/(2*math.tan((delta/2)*(math.pi/180))), tol),_warning
					end
				
				else 
					return RcType..": ERROR - Bad connection object type",_error
				end
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_com_chkConnectionElevationMatch()" ReturnType="String"
		Description="Checks that alignment elevations (Z-coordinate) match at the connection." >
		<Constructor>String NOBN_com_chkConnectionElevationMatch()</Constructor>
		<Formula>
			function NOBN_com_chkConnectionElevationMatch()
				tol = 0.030  -- meter
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				if RcType ~= "JBTEH_ISO Lineisolator" and TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end

				if RcType == "JBTEH_ISO Lineisolator" and TargetAlignment == nil then
						return "-: OK – Object does not act as a connection (being too far from any potential target alignment).",_ok
			
				elseif RcType == "JBTKO_SPF Sporfortsettelse" 
				or RcType == "JBTEH_LEF Ledningfortsettelse" 
				or RcType == "JBTEH_KTF Kontaktledningfortsettelse" 
				or RcType == "JBTEH_ISO Lineisolator"
				then
					if ExtendingFromEnd then 
						z1 = Alignment.RcAlignment.EndPoint.Z
					else
						z1 = Alignment.RcAlignment.StartPoint.Z
					end 
					if ContinuingWithBegin then
						z2 = TargetAlignment.RcAlignment.StartPoint.Z
					else 
						z2 = TargetAlignment.RcAlignment.EndPoint.Z
					end
					delta = z2 - z1 -- meter difference in elevations at connection
			
				elseif RcType == "JBTKO_SPV Sporveksel" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					p1 = getAlignmentInfo().Point		--The projection of the StockRailJoint onto its own alignment
					d1 = RC__getDistance2D(TargetAlignment.RcAlignment.StartPoint,p1)
					d2 = RC__getDistance2D(TargetAlignment.RcAlignment.EndPoint,p1)
					z1 = p1.Z 							--TopOfRail where StockRailJoint is projected onto own alignment
					if d1 &lt; d2 then
						z2 = TargetAlignment.RcAlignment.StartPoint.Z
					else
						z2 = TargetAlignment.RcAlignment.EndPoint.Z
					end
			
				elseif RcType == "JBTKO_SPV Sporkryss" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					if not getAlignmentInfo(TargetAlignment.id).NormalProjectionExists then
						return TargetAlignment.code..": WARNING - Connection object has no projection onto its target alignment (cannot compute mileage).",_warning
					end
					z1 = getAlignmentInfo().Elevation
					z2 = getAlignmentInfo(TargetAlignment.id).Elevation
				
				else 
					return RcType..": ERROR - Bad connection object type",_error
				end
				if RC__isNan(z1) then z1 = 0 end
				if RC__isNan(z2) then z2 = 0 end
				delta = z2 - z1 -- meter difference in elevations at connection
				if (math.abs(delta) &lt; tol / 2) then return string.format("%.03f (%.03f / %.03f)",delta,z1,z2) .. ": OK - Elevations match within 50% of tolerance +/- " .. string.format("%.03f", tol).." m.",_ok
				elseif (math.abs(delta) &lt; tol) then return string.format("%.03f (%.03f / %.03f)",delta,z1,z2) .. ": WARNING – Elevations match, but close to tolerance +/- " .. string.format("%.03f", tol).." m.",_warning
				else return string.format("%.03f (%.03f / %.03f)",delta,z1,z2) .. ": ERROR – Elevations are too different, outside tolerance +/- " .. string.format("%.03f", tol).." m.",_error end
			end
		</Formula>
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_com_chkConnectionGradientMatch()" ReturnType="String"
		Description="Checks the continuity of gradient through the connection." >
		<Constructor>NOBN_com_chkConnectionGradientMatch()</Constructor>
		<Formula>
			function NOBN_com_chkConnectionGradientMatch()
				tol = 1.0  -- o/oo (per mille, elevation change per thousand meters running length)
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				if RcType ~= "JBTEH_ISO Lineisolator" and TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end

				if RcType == "JBTEH_ISO Lineisolator" and TargetAlignment == nil then
						return "-: OK – Object does not act as a connection (being too far from any potential target alignment).",_ok
			
				elseif RcType == "JBTKO_SPF Sporfortsettelse" 
				or RcType == "JBTEH_LEF Ledningfortsettelse" 
				or RcType == "JBTEH_KTF Kontaktledningfortsettelse" 
				or RcType == "JBTEH_ISO Lineisolator"
				then
					--find gradient in o/oo from the tangent vector at the alignment's ends, where there ends are closest
					if ExtendingFromEnd then 
						t = Alignment.RcAlignment.EndTangent
						g1 = 1000*math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
						t1 = Alignment.RcAlignment.HorizontalProfile.EndDir
					else
						t = Alignment.RcAlignment.StartTangent
						g1 = 1000*math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
						t1 = Alignment.RcAlignment.HorizontalProfile.Segments[0].StartDir
					end 
					if ContinuingWithBegin then
						t = TargetAlignment.RcAlignment.StartTangent
						g2 = 1000*math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
						t2 = TargetAlignment.RcAlignment.HorizontalProfile.Segments[0].StartDir
					else 
						t = TargetAlignment.RcAlignment.EndTangent
						g2 = 1000*math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
						t2 = TargetAlignment.RcAlignment.HorizontalProfile.EndDir
					end
			
				elseif RcType == "JBTKO_SPV Sporveksel" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
			
					--Own alignment's gradient and direction at stock rail joint:
					t = getAlignmentInfo().Tangent
					g1 = 1000*math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
					t1 = math.atan(t.Y,t.X) * (180/math.pi)
			
					--Target alignment's gradient and direction where branch track takes off from own alignment:
					p1 = getAlignmentInfo().Point --The projection of the StockRailJoint onto its own alignment
					d1 = RC__getDistance2D(TargetAlignment.RcAlignment.StartPoint,p1)
					d2 = RC__getDistance2D(TargetAlignment.RcAlignment.EndPoint,p1)
					if d1 &lt; d2 then
						t = TargetAlignment.RcAlignment.StartTangent
						g2 = 1000 * math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
						t2 = (180/math.pi) * math.atan(t.Y, t.X)
					else
						t = TargetAlignment.RcAlignment.EndTangent
						g2 = 1000*math.atan(t.Z, math.sqrt(t.X^2 + t.Y^2))
						t2 = (180/math.pi) * math.atan(t.Y, t.X)
					end
			
				else 
					return RcType..": ERROR - Bad connection object type",_error
				end
			
				-- Return o/oo difference in gradients at connection:
				if math.cos(t2-t1) > 0 then
					-- Same mileage directions
					delta = g2 - g1
				else 
					-- Opposite mileage directions
					delta = g2 - (-g1)
				end
				if (math.abs(delta) &lt; tol / 2) then
					return string.format("%.03f (%.03f / %.03f)",delta,g1,g2) .. ": OK - Gradients match within 50% of tolerance +/- " .. string.format("%.03f", tol).." o/oo.",_ok
				elseif (math.abs(delta) &lt; tol) then
					return string.format("%.03f (%.03f / %.03f)",delta,g1,g2) .. ": WARNING – Gradients match, but close to tolerance +/- " .. string.format("%.03f", tol).." o/oo.",_warning
				else 
					return string.format("%.03f (%.03f / %.03f)",delta,g1,g2) .. ": ERROR – Gradients are too different, outside tolerance +/- " .. string.format("%.03f", tol).." o/oo.",_error
				end
			end
		</Formula>
	</LuaFunction>
	
	
	
	
	<LuaFunction Name="NOBN_com_chkConnectionCantMatch()" ReturnType="String"
		Description="Checks the cant (superelevation) continuity through the connection." >
		<Constructor>NOBN_com_chkConnectionCantMatch()</Constructor>
		<Formula>
			function NOBN_com_chkConnectionCantMatch()
				tol = 0.010  -- cant (superelevation) [m]
				msg = ""
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				if RcType ~= "JBTEH_ISO Lineisolator" and TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end

				if RcType == "JBTEH_ISO Lineisolator" and TargetAlignment == nil then
						return "-: OK – Object does not act as a connection (being too far from any potential target alignment).",_ok
			
				elseif RcType == "JBTKO_SPF Sporfortsettelse" 
				or RcType == "JBTEH_LEF Ledningfortsettelse" 
				or RcType == "JBTEH_KTF Kontaktledningfortsettelse" 
				or RcType == "JBTEH_ISO Lineisolator"
				then
					if ExtendingFromEnd then
						p1 = Alignment.RcAlignment.EndPoint
					else
						p1 = Alignment.RcAlignment.StartPoint
					end 
					if ContinuingWithBegin then
						p2 = TargetAlignment.RcAlignment.StartPoint
					else 
						p2 = TargetAlignment.RcAlignment.EndPoint
					end
					z1 = getAlignmentInfo(p1).Cant
					z2 = getAlignmentInfo(TargetAlignment.id,p2).Cant
				
				elseif RcType == "JBTKO_SPV Sporveksel" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					p1 = getAlignmentInfo().Point		--The projection of the StockRailJoint onto its own alignment
					d1 = RC__getDistance2D(TargetAlignment.RcAlignment.StartPoint,p1)
					d2 = RC__getDistance2D(TargetAlignment.RcAlignment.EndPoint,p1)
					z1 = getAlignmentInfo().Cant
					if d1 &lt; d2 then
						z2 = getAlignmentInfo(TargetAlignment.id,TargetAlignment.RcAlignment.StartPoint).Cant		
					else
						z2 = getAlignmentInfo(TargetAlignment.id,TargetAlignment.RcAlignment.EndPoint).Cant			
					end
			
				else 
					return RcType..": ERROR - Bad connection object type",_error
				end
			
				if RC__isNan(z1) then z1 = 0 end
				if RC__isNan(z2) then z2 = 0 end
				delta = z2 - z1 -- difference [mm] in superelevations at connection
				-- Presentation in meters:
				--TODO: Check all combinations of CW, CCW and track directions
				delta = delta/1000
				if (math.abs(delta) &lt; tol / 2) then return string.format("%.03f (%.03f / %.03f)",delta,z1,z2) .. ": OK - Cants match within 50% of tolerance +/- " .. string.format("%.03f", tol).." m.",_ok
				elseif (math.abs(delta) &lt; tol) then return string.format("%.03f (%.03f / %.03f)",delta,z1,z2) .. ": WARNING – Cants match, but close to tolerance +/- " .. string.format("%.03f", tol).." m.",_warning
				else return string.format("%.03f (%.03f / %.03f)",delta,z1,z2) .. ": ERROR – Cants are too different, outside tolerance +/- " .. string.format("%.03f", tol).." m.",_error end
			end
		</Formula>
	</LuaFunction>


	
	
	
<!--========================================================================================================
    TRACK
=========================================================================================================-->
			
<xpp:define name="NOBN_trk_CHK_CONNECTION___CROSSING" >
	<xpp:bloc>
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_AlignmentType" DisplayName="Alignment type" Description="Both alignments must be railway tracks." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Continuity" DisplayName="Continuity" Description="The crossing shall be located where the tracks' center lines cross (as seen from the above, ignoring Z)." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Tangent" DisplayName="Tangent direction" Description="The tracks are expected to cross at 2:9 or 2:12 (corresponding to 1:9 or 1:12 coupled switches)." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Elevation" DisplayName="Elevation" Description="The tracks shall share the same elevation (Z-coordinate) at the crossing point." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_GradientAndCant" DisplayName="Rail plane" Description="The tracks shall share the same combined gradient and cant (belonging to a possibly inclined plane in space)." />
		<LuaExpression Name="mc_AlignmentType" IsModelCheck="true" > <Formula>NOBN_com_chkConnectionAlignmentCompatibility()</Formula></LuaExpression>
		<LuaExpression Name="mc_Continuity" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionContinuity()</Formula></LuaExpression>
		<LuaExpression Name="mc_Tangent" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionTangentMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Elevation" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionElevationMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_GradientAndCant" IsModelCheck="true" ><Formula>NOBN_trk_chkConnectionGradientAndCantMatch()</Formula></LuaExpression>
	</xpp:bloc>
</xpp:define>
			
<xpp:define name="NOBN_trk_CHK_CONNECTION___SWITCH" >
	<xpp:bloc>
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_AlignmentType" DisplayName="Alignment type" Description="Both alignments must be railway tracks." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Continuity" DisplayName="Continuity" Description="The switch's stock rail joint must be located on its own alignment, the branching track shall start or end in the through track." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Tangent" DisplayName="Tangent direction" Description="The tracks shall share the same tangent where they meet (i.e., XY-plane differentiability when turning out) ." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Elevation" DisplayName="Elevation" Description="The through track and the branch track shall share the same elevation at the stock rail joint (Z-coordinate)." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Gradient" DisplayName="Gradient" Description="The tracks shall share the same  gradient (pitch) at the stock rail joint [o/oo]." />
		<CustomAttribute DataType="String" ReadOnly="true" Category="Model check" Name="mc_Cant" DisplayName="Cant" Description="The tracks shall share the same cant (roll / superelevation) at the stock rail joint [mm]." />
		<LuaExpression Name="mc_AlignmentType" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionAlignmentCompatibility()</Formula></LuaExpression>
		<LuaExpression Name="mc_Continuity" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionContinuity()</Formula></LuaExpression>
		<LuaExpression Name="mc_Tangent" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionTangentMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Elevation" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionElevationMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Gradient" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionGradientMatch()</Formula></LuaExpression>
		<LuaExpression Name="mc_Cant" IsModelCheck="true" ><Formula>NOBN_com_chkConnectionCantMatch()</Formula></LuaExpression>
	</xpp:bloc>
</xpp:define>
			



	
	<LuaFunction Name="NOBN_trk_chkConnectionGradientAndCantMatch()" ReturnType="String"
		Description="Checks the cant (superelevation) continuity through the connection." >
		<Constructor>NOBN_trk_chkConnectionGradientAndCantMatch(callingProperty)</Constructor>
		<Formula>
			function NOBN_trk_chkConnectionGradientAndCantMatch(CallingProperty)
				-- 'CallingProperty' ["Var0" | "Var1"] identifies the intended custom property where the result is to be returned (since this function does not know otherwise who is calling)
				tol = 0.300  -- Decimal degrees
				msg = "" -- to be returned with _info(msg)
				if Alignment == nil then return "UNFINISHED - Missing own alignment." end
				--Drop distance2D check here - is covered in other test:
				--if math.abs(DistanceToAlignment) &gt; 2e-3 then return string.format("%.03f",DistanceToAlignment)..
				--	": WARNING - Distance (2D) to own alignment should be close to zero.",_warning end
				if TargetAlignment == nil then return "UNFINISHED - Missing target alignment." end
				if RcType == "JBTKO_SPV Sporkryss" then
					if not getAlignmentInfo().NormalProjectionExists then
						return Alignment.code..": WARNING - Connection object has no projection onto its own alignment (cannot compute mileage).",_warning
					end
					if not getAlignmentInfo(TargetAlignment.id).NormalProjectionExists then
						return TargetAlignment.code..": WARNING - Connection object has no projection onto its target alignment (cannot compute mileage).",_warning
					end
					-- Get info about the projections of the Crossing onto its own / its target alignment
					a1 = getAlignmentInfo() --own alignment
					a2 = getAlignmentInfo(TargetAlignment.id) --target alignment
			
					-- Crossing's projection onto own and target alignments [3D vector {X,Y,Z}]:
					p1 = a1.Point						
					p2 = a2.Point
					
					-- Alignments' tangential, normalized, vectors at projection points [3D vector {X,Y,Z}]:
					t1 = getAlignmentInfo().Tangent
					t2 = getAlignmentInfo(TargetAlignment.id).Tangent
					if t1 == nil or t2 == nil then return "UNFINISHED - Missing elevation data, cannot compute normal vector(s)." end
			
					-- Alignment direction phi wrt WCS East [rad]:
					phi1 = math.atan(a1.Tangent.y,a1.Tangent.x)
					phi2 = math.atan(a2.Tangent.y,a2.Tangent.x)
					
					-- JigSymbolAppearance angle rho ("rholl"...) theta (zenith angles) due to cant [rad] (roll with cant):
					h1 = a1.Cant/1000.0
					h2 = a2.Cant/1000.0
					if RC__isNan(h1) and RC__isNan(h2) then 
						msg = "UNFINISHED -  Missing cant data in both alignments, assuming zero cant."
					elseif RC__isNan(h1) then 
						msg = "UNFINISHED -  Missing cant data in own alignment, assuming zero cant."
					elseif RC__isNan(h2) then 
						msg = "UNFINISHED -  Missing cant data in crossing (target) alignment, assuming zero cant."
					end
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
					tcg = TargetAlignment.AlignmentSystem.CantGauge
					if tcg ~= cg then return ": ERROR - cant gauges are not identical in the two alignments: "..string.format("%.3f / %.3f",cg,tcg),_error end 
					if RC__isNan(h1) then 
						h1 = 0.0
						rho1 = 0.0
					else
						rho1 = math.asin((a1.CantRotation=="CCW" and h1 or -h1) / cg) 
					end
					if RC__isNan(h2) then
						h2 = 0.0
						rho2 = 0.0
					else
						rho2 = math.asin((a2.CantRotation=="CCW" and h2 or -h2) / cg) 
					end
					
					-- Rotation angle theta ('thilt'...) around the Alignment Coordinate System Y-axis (perp to track direction), Z pointing straight up (pitch with gradient)
					theta1 = math.atan(t1.z,math.sqrt(t1.x^2+t1.y^2)) 
					theta2 = math.atan(t2.z,math.sqrt(t2.x^2+t2.y^2)) 
			
					--Start with normal vector (0,0,1)
					n = {x="0.0",y="0.0",z="1.0"}
			
					--Then, apply zenith angle rho (roll) in the coordinate system where the 'x' axis points along the track direction:
					u1 = {x="0.0",y="0.0",z="0.0"}
					u1.x = 0.0
					u1.y = math.cos(rho1)*n.y - math.sin(rho1)*n.z
					u1.z = math.sin(rho1)*n.y + math.cos(rho1)*n.z
			
					u2 = {x="0.0",y="0.0",z="0.0"}
					u2.x = 0.0
					u2.y = math.cos(rho2)*n.y - math.sin(rho2)*n.z
					u2.z = math.sin(rho2)*n.y + math.cos(rho2)*n.z
			
					--Then, pitch the rolled normal vector with theta (tilt) around the second axis in the same axis system (perpendicular to the track direction):
					v1 = {x="0.0",y="0.0",z="0.0"}
					v1.x = math.cos(theta1)*u1.x - math.sin(theta1)*u1.z
					v1.y = u1.y
					v1.z = math.sin(theta1)*u1.x + math.cos(theta1)*u1.z
				
					v2 = {x="0.0",y="0.0",z="0.0"}
					v2.x = math.cos(theta2)*u2.x - math.sin(theta2)*u2.z
					v2.y = u2.y
					v2.z = math.sin(theta2)*u2.x + math.cos(theta2)*u2.z
						
					--Finally, express vectors in WCS coordinates, i.e rotate by phi (the forward direction in the WCS XY plane) around the WCS Z axis:
					w1 = {x="0.0",y="0.0",z="0.0"}
					w1.x = math.cos(phi1)*v1.x - math.sin(phi1)*v1.y
					w1.y = math.sin(phi1)*v1.x + math.cos(phi1)*v1.y 
					w1.z = v1.z 
				
					w2 = {x="0.0",y="0.0",z="0.0"}
					w2.x = math.cos(phi2)*v2.x - math.sin(phi2)*v2.y 
					w2.y = math.sin(phi2)*v2.x + math.cos(phi2)*v2.y 
					w2.z = v2.z
				
					--Assert normalized vectors:
					d1 = math.sqrt(w1.x^2+w1.y^2+w1.z^2)
					if math.abs(d1-1.000) > 4e-4 then return RC__round(d1,3)..": ERROR - w1 not unit vector.",_error end 
					d2 = math.sqrt(w2.x^2+w2.y^2+w2.z^2)
					if math.abs(d2-1.000) > 4e-4 then return RC__round(d2,3)..": ERROR - w2 not unit vector.",_error end 
					
					--Find 3D angle between normal vectors (knowing that cos(delta) = (w1.w2)/(|w1|*|w2|) - and both vectors are already of length 1. 
					delta = math.acos(w1.x*w2.x + w1.y*w2.y + w1.z*w2.z) * 180/math.pi 
			
					if (CallingProperty == "Var1") then
						return string.format("delta= %.04f",delta)
						..string.format(", rho= %.04f / %.04f",rho1*180/math.pi,rho2*180/math.pi)
						..string.format(", theta= %.04f / %.04f",theta1*180/math.pi,theta2*180/math.pi)
						..string.format(", phi= %.04f / %.04f",phi1*180/math.pi,phi2*180/math.pi)
					end
			
					if (CallingProperty == "Var2") then
						return string.format("N=(%.04f,%.04f,%.04f) / (%.04f,%.04f,%.04f)",
						-math.cos(phi1)*math.sin(theta1)*math.cos(rho1) + math.sin(phi1)*math.sin(rho1),
						-math.sin(phi1)*math.sin(theta1)*math.cos(rho1) - math.cos(phi1)*math.sin(rho1),
						math.cos(theta1)*math.cos(rho1),
						-math.cos(phi2)*math.sin(theta2)*math.cos(rho2) + math.sin(phi2)*math.sin(rho2),
						-math.sin(phi2)*math.sin(theta2)*math.cos(rho2) - math.cos(phi2)*math.sin(rho2),
						math.cos(theta2)*math.cos(rho2)
						)
					end
					
				else 
					return RcType..": ERROR - Bad connection object type",_error, _info(msg)
				end
			
				if (math.abs(delta) &lt; tol / 2.0) then return string.format("%.03f",delta) .. ": OK - Normal vectors match within 50% of tolerance +/- " .. string.format("%.03f",tol).." degrees.",_ok, _info(msg)
				elseif (math.abs(delta) &lt; tol) then return string.format("%.03f",delta) .. ": WARNING – Normal vectors match, but close to tolerance +/- " .. string.format("%.03f",tol).." degrees.",_warning, _info(msg)
				else return string.format("%.03f",delta) .. ": ERROR – Normal vectors are too different, outside tolerance +/- " .. string.format("%.03f",tol).." degrees.",_error, _info(msg) end
			end		
		</Formula>
	</LuaFunction>



<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>
<!--========================================================================================================

    NO-BN-General-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml" />.

	(c) Railcomplete AS, Norway, 2015-2023. All rights reserved.
	
=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
    RC general and railway-independent Lua
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
	<LuaFunction Name="RC__getDnaVersion()" ReturnType="String"
		Description="Returns a collection of objects connected through the specified relation, and the number of related objects found. Source object and visibility are optional arguments." >
		<Constructor>int RC__getDnaVersion(double x)</Constructor>
		<Formula>
			function RC__getDnaVersion()
				return DocumentData.DnaIri:match("^(.-);.-$") .."-".. DocumentData.DnaIri:match(".+;(.+)$")
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__toInt()" ReturnType="Int"
		Description="Returns an integer from an integer or floating-point input." >
		<Constructor>int RC__toInt(double x)</Constructor>
		<Formula>function RC__toInt(x) return string.format("%.0f",x) end</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__TextAttributePosition()" ReturnType="Vector2D" 
			HideFromUser="false"
			Description="Returns a WCS offset vector for placing a text attribute relative to its object's insertion point. The text changes side of alignment if the object changes side.
			\n\nReturns a World Coordinate System offset vector in the current drawing scale for a text attribute. Input coordinates provide the acsX = lateral offset (positive to the right side of the object's alignment) and the acsY = longitudinal offset (positive in the direction of increasing mileages), both stated for drawing scale 1:1 (1:1000)." >
		<Constructor>{Double,Double} RC__TextAttributePosition(Double lateralOffset, Double longitudinalOffset)</Constructor>
		<Formula>
			function RC__TextAttributePosition(lateralOffset,longitudinalOffset)
				scale = DocumentData.Document.Database.Cannoscale.Scale --CAD system's annotative scale
				lateralOffset = (lateralOffset or 5)/scale
				longitudinalOffset = (longitudinalOffset or 0)/scale
				return RC__getWcsVectorFromAcsVector(RightSided and lateralOffset or -lateralOffset,longitudinalOffset)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngleFromDir()" ReturnType="Double"
		Description="Returns the angle in Decimal Degrees corresponding to the given direction [up | down | both | none | unknown]. 'Direction' and 'Rightsided' are optional arguments." >
		<Constructor>Double RC__getAngleFromDir([LaxDirection Direction [,Boolean RightSided]])</Constructor>
		<Formula>
			function RC__getAngleFromDir(d,rs)
				if d == nil then
					d = dir
					rs = RightSided
				elseif rs == nil then
					rs = false
				end
				if dir == 'up' then return 0
				elseif dir == 'down' then return 180
				elseif dir == 'both' then return rs and -90 or 90
				elseif dir == 'none' then return rs and 90 or -90 
				elseif dir == 'unknown' then return 45 
				else return 45, _info("Bad direction '"..d.."'.")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getMileageFromRelatedObject()" ReturnType="Double"
		Description="Returns the mileage for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getMileageFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getMileageFromRelatedObject(RelationName,Source)
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Mileage"),_warning, _info("Missing relation name in function call.")
				end
				local r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Mileage"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDistanceToAlignmentFromRelatedObject()" ReturnType="Double"
		Description="Returns the distance to alignment for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getDistanceToAlignmentFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getDistanceToAlignmentFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("DistanceToAlignment"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("DistanceToAlignment"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("DistanceToAlignment deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("DistanceToAlignment deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getRelativeElevationFromRelatedObject()" ReturnType="Double"
		Description="Returns the relative elevation above for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getRelativeElevationFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getRelativeElevationFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("RelativeElevation"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("RelativeElevation"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("RelativeElevation deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("RelativeElevation deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngularOffsetFromRelatedObject()" ReturnType="Double"
		Description="Returns the angular offset for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getAngularOffsetFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getAngularOffsetFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("AngularOffset"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("AngularOffset"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDirFromRelatedObject()" ReturnType="Double"
		Description="Returns the direction (Dir) from related object. Source object is an optional argument." >
		<Constructor>Double RC__getDirFromRelatedObject(String RelationName [,Reference SourceObject])</Constructor>
		<Formula>
			function RC__getDirFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Dir"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Dir"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].Dir, _info("Direction (Dir) deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("Direction (Dir) deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getWcsVectorFromAcsVector()" ReturnType="String"
		Description="Converts an Alignment Coordinate System (ACS) 2D vector into a World Coordinate System (WCS) 2D vector. Usage: wx,wy = RC__getWcsVectorFromAcsVector(lateralOffset,longitudinalOffset) or wx,wy = RC__getWcsVectorFromAcsVector(lateralOffset,longitudinalOffset,alongAxisWcsAngleInRadians)." >
		<Constructor>{Double,Double} RC__getWcsVectorFromAcsVector(lateralOffset,longitudinalOffset [,alongAxisWcsAngleInRadians = this.AlignmentTangent])</Constructor>
		<Formula>
			function RC__getWcsVectorFromAcsVector(acsX,acsY,alongAxisWcsAngleInRadians)
				--WCS = World Coordinate System, the CAD system's underlying absolute Cartesian coordinate system (XY-plane).
				--ACS = "Alignment Coordinate System", a basic RailCOMPLETE concept:
				--	Argument acsX = Lateral offset to the right, perpendicular to the object's alignment axis.
				--	Argument acsY = Along offset in the direction of increasing distAlong, along the object's alignment axis.
				--	Optional argument alongAxisWcsAngleInRadians = angle in Decimal Degrees between WCS East (X-axis) and the alignment's tangent direction.
				local angle = alongAxisWcsAngleInRadians or AlignmentTangent
				return  acsX*math.sin(angle) + acsY*math.cos(angle), -acsX*math.cos(angle) + acsY*math.sin(angle)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__identify()" ReturnType="String"
		Description="Returns the object's name if non-empty, or its code if non-empty, otherwise returns its ID. Addresses the calling object if no object reference is given." >
		<Constructor>String RC__identify([Reference obj])</Constructor>
		<Formula>
			function RC__identify(obj)
				obj = obj or this
				if type(obj) ~= "table" then
					return "ERROR: RC__identify() called with a bad argument type '"..type(obj).."', an objRef was expected."
				end
				objName = obj:getPropertyValue("name")
				objCode = obj:getPropertyValue("code")
				objId = obj:getPropertyValue("id")
				if objName ~= nil and objName ~= "" then return objName
				elseif objCode ~= nil and objCode  ~= "" then return objCode
				else return tostring(objId)
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isNan()" ReturnType="Bool"
		Description="Returns true if input value is NaN (not a number), otherwise returns false." >
		<Constructor>Bool RC__isNan(Double value)</Constructor>
		<Formula>function RC__isNan(x) return x ~= x end</Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getUrlExtension()" ReturnType="String"
		Description="Returns filename extension (file type). Default url is the current document." >
		<Constructor>String RC__getUrlExtension([String url])</Constructor>
		<Formula>
			function RC__getUrlExtension(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[%.]([^%.]-)$") -- Extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDriveAndFolderAndFilename()" ReturnType="String"
		Description="Returns drive letter, folder name and file name. Default url is the current document." >
		<Constructor>String RC__getUrlDriveAndFolderAndFilename([String url])</Constructor>
		<Formula>
			function RC__getUrlDriveAndFolderAndFilename(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[%.][^%.]-$") -- Drive letter, folder and filename without extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDriveAndFolder()" ReturnType="String"
		Description="Returns drive letter and folder name. Default url is the current document." >
		<Constructor>String RC__getUrlDriveAndFolder([String url])</Constructor>
		<Formula>
			function RC__getUrlDriveAndFolder(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[\\/][^\\/]-$") -- Drive letter and folder name
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDrive()" ReturnType="String"
		Description="Returns drive letter. Default url is the current document." >
		<Constructor>String RC__getUrlDrive([String url])</Constructor>
		<Formula>
			function RC__getUrlDrive(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[:][^:]-$") -- Drive letter(s)
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlFilename()" ReturnType="String"
		Description="Returns filename without extension. Default url is the current document." >
		<Constructor>String RC__getUrlFilename([String url])</Constructor>
		<Formula>
			function RC__getUrlFilename(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[\\/]?([^\\/]-)[%.][^%.]-$") -- Filename without extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlFilenameAndExtension()" ReturnType="String"
		Description="Returns filename with extension. Default url is the current document." >
		<Constructor>String RC__getUrlFilenameAndExtension([String url])</Constructor>
		<Formula>
			function RC__getUrlFilenameAndExtension(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[\\/]?([^\\/]-)$") -- Filename and extension
			end
		</Formula>
	</LuaFunction>



	<!-- Special sub() pattern control characters are introduced with a byte in the range from 128 to 191, followed by a second byte that gives the  -->
	<!-- actual character, in combination with the first character. -->
	<!-- ^ anchors to start of string. \nnn means "byte contents nnn in decimal". * means "zero or more occurrences". $ means "pattern is anchored to end of string". -->
	<!-- RC__sub("skjØrteMåLET",9) == "åLET" -->
	<!-- RC__sub("skjØrteMåLET",3) == "jØrteMåLET" -->
	<!-- RC__sub("skjØrteMåLET",12) == "T" -->
	<!-- RC__sub("skjØrteMåLET",13) == "" -->
	<!-- RC__sub("skjØrteMåLET",1,1) == "s" -->
	<!-- RC__sub("skjØrteMåLET",4,3) == "" -->
	<!-- RC__sub("skjØrteMåLET") == "skjØrteMåLET" -->
	<!-- RC__sub("") == "" -->
	<!-- RC__sub() == "" -->
	<LuaFunction Name="RC__sub()" ReturnType="String"
		Description="Returns a substring of the input string, starting with its i-th multibyte letter and ending with its j-th multibyte letter (the built-in Lua method sub() will treat a string just as an array of individual bytes). By default, i=1 and j=i." >
		<Constructor>String RC__sub(String s [,Int i [,Int j]])</Constructor>
		<Formula>
			function RC__sub(s,i,j)
				return s, _info("*** Function RC__sub(String s [,Int i [,Int j]]) has not been implemented yet"),_warning
			end
        </Formula>
	</LuaFunction>

  

	<LuaFunction Name="RC__round()" ReturnType="String"
		Description="Rounds floating point input x to p [-6..6] decimal places. Default precision is 0 decimals." >
		<Constructor>Double RC__round(Double x [, Int p])</Constructor>
		<Formula>
			function RC__round(x,p) 
				if math.abs(x) == math.huge then return x end --plus/minus Inf
				if p == nil then p = 0 end
				p = math.floor(p)
				if p &lt; -6 or p &gt; 6 then
					return "Precision ["..p.."] must be from -6 to 6, cannot format value ["..x.."]",_warning
				elseif p == 6 then x = string.format("%.6f",math.floor((x+0.5*1e-6)*1e6)/1e6)
				elseif p == 5 then x = string.format("%.5f",math.floor((x+0.5*1e-5)*1e5)/1e5) 
				elseif p == 4 then x = string.format("%.4f",math.floor((x+0.5*1e-4)*1e4)/1e4) 
				elseif p == 3 then x = string.format("%.3f",math.floor((x+0.5*1e-3)*1e3)/1e3) 
				elseif p == 2 then x = string.format("%.2f",math.floor((x+0.5*1e-2)*1e2)/1e2) 
				elseif p == 1 then x = string.format("%.1f",math.floor((x+0.5*1e-1)*1e1)/1e1) 
				elseif p == 0 then x = string.format("%d",math.floor((x+0.5*1e0)*1e0)/1e0)
				elseif p == -1 then x = string.format("%d",math.floor((x+0.5*1e1)*1e-1)/1e-1) 
				elseif p == -2 then x = string.format("%d",math.floor((x+0.5*1e2)*1e-2)/1e-2)
				elseif p == -3 then x = string.format("%d",math.floor((x+0.5*1e3)*1e-3)/1e-3)
				elseif p == -4 then x = string.format("%d",math.floor((x+0.5*1e4)*1e-4)/1e-4)
				elseif p == -5 then x = string.format("%d",math.floor((x+0.5*1e5)*1e-5)/1e-5)
				elseif p == -6 then x = string.format("%d",math.floor((x+0.5*1e6)*1e-6)/1e-6)
				end
				return tonumber(x)
			end
        </Formula>
	</LuaFunction>

  
  
	<LuaFunction Name="RC__getNearestSnapDistance()" ReturnType="String"
		Description="Returns nearest multiple of step size. Default step size is 3. E.g., '4.51' => '6' and '-7.49' => '-6'." >
		<Constructor>Double RC__getNearestSnapDistance(Double x [, Double stepSize])</Constructor>
		<Formula>
			function RC__getNearestSnapDistance(x,stepSize) 
				if stepSize == nil then 
					if x == nil then
						return RightSided and 4e-4 or -4e-4,_warning
					else
						stepSize = 3
					end
				end
				stepSize = math.floor(math.abs(stepSize))
				if stepSize == 0 then
					return RightSided and 4e-4 or -4e-4
				else
					local y = stepSize * math.floor((x / stepSize) + 0.5)
					return y == 0 and (RightSided and 4e-4 or -4e-4) or y
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isMemberOf()" ReturnType="Boolean" 
		Description="Returns true if table/collection/dictionary contains item. The item may be part of a numbered Lua sequence {2,3,5,7,11} or a value in a key/value pair {x=1,y=1,z=2,t=3,u=5}. Advice: When looking for objects, look for its id property item.id (a text string) rather than an object reference, as objects may be relocated in memory for each Lua execution." >
		<Constructor>Boolean RC__isMemberOf(Table t, Item item)</Constructor>
		<Formula>
			function RC__isMemberOf(t,item) 
				local i
				if getTableValue(t) == nil and type(t) == "table" then
					-- A genuine Lua table, convert it to RailCOMPLETE/C# collection object (deleting the keys from key/value pairs):
					t = getCollectionFromTable(t)
					--Collections respond correctly to the '.count' attribute:
					for i = 0, t.count-1 do
						if type(item) == "string" or type(item) == "number" then
							if t[i] == item then
								return true
							end
						elseif item.id then
							if t[i].id == item.id then
								return true
							end
						end
					end
				end
				return false
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__NumberCollection()" ReturnType="Table"
		Description="Returns a sorted table (indexed 1,2,...)." >
		<Constructor>table RC__NumberCollection(table t)</Constructor>
		<Formula>
			function RC__NumberCollection(t)
				local u,v,n,i,j,k,lo
				if t == nil then return nil,_error end
				if type(t) ~= type({}) then return '***',_warning end
				t = getCollectionFromTable(t)
				--Insertion sort, ok for small tables. TODO: Implement QuickSort for larger tables.
				u = {}
				v = {}
				n = 0
				while t[n+1] do
					n = n + 1
					table.insert(u,t[n])
				end		
				for i = 1, n do
					lo = math.huge
					for j = 1, n-i+1 do
						if u[j] &lt; lo then 
							lo = u[j]
							k = j 
						end
					end
					table.insert(v,table.remove(u,k)) --insert smallest number from u into v
				end
				return v
			end 
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__getDistance2D()" ReturnType="Double"
		Description="Returns the Euclidian distance in the XY plane between inputs p1 and p2 (point objects or Point3D), each being geoCoord or table {['X']=x,['Y']=y}. p2 is by default the calling object. Z's are ignored." >
		<Constructor>Double RC__getDistance2D(Point p1 [,Point p2])</Constructor>
		<Formula>
			function RC__getDistance2D(p1,p2) 
				local x1,x2,y1,y2
				if p1 == nil then 
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					--Ordinary RailwayPlacedObject:
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
				elseif p1.X then 
					--Point3D:
					x1 = p1.X
					y1 = p1.Y
				else
					return 0,_warning, _info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					--Ordinary RailwayPlacedObject:
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
				elseif p2.X then
					--Point3D:
					x2 = p2.X
					y2 = p2.Y
				else
					return 0,_warning, _info("Second point has no X coordinate.")
				end
				return math.sqrt(math.pow(x2-x1,2) + math.pow(y2-y1,2))
			end
        </Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getDistance3D()" ReturnType="Double"
		Description="Returns the Euclidian distance in XYZ space between inputs p1 and p2 (point objects or Point3D), each being geoCoord or table {['X']=x,['Y']=y,['Z']=z}. p2 is by default the calling object. Z's are 0 if missing." >
		<Constructor>Double RC__getDistance3D(Point p1 [,Point p2])</Constructor>
		<Formula>
			function RC__getDistance3D(p1,p2) 
				local x1,x2,y1,y2,z1,z2
				-- This code will work both for railML geoCoord entities and for tables using "X", "Y" and "Z" as indices. 
				if p1 == nil then
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
					z1 = p1.geoCoord.Z
				elseif p1.X then 
					x1 = p1.X
					y1 = p1.Y
					z1 = p1.Z == nil and 0 or p1.Z
				else
					return 0,_warning, _info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
					z2 = p2.geoCoord.Z
				elseif p2.X then 
					x2 = p2.X
					y2 = p2.Y
					z2 = p2.Z == nil and 0 or p2.Z
				else
					return 0,_warning, _info("Second point has no X coordinate.")
				end
				return math.sqrt(math.pow(x2-x1,2) + math.pow(y2-y1,2) + math.pow(z2-z1,2))
			end
        </Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC_getAreasOfVariant()" ReturnType="Collection of RcArea"
		Description="Returns a count and a collection of visible areas of the given variant, enclosing the object." >
        <Constructor>Int, Collection of RcArea RC_getAreasOfVariant(String areaVariantName [, String guidString])</Constructor>
        <Formula>
			function RC_getAreasOfVariant(areaVariantName, guidString)
				local obj = guidString and getObjectFromId(guidString) or this
				local areas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:match(areaVariantName) end)
				return areas.count,areas
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
    RC common Lua, general railway-specific issues, present in any railway administration
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
<!--========================================================================================================
	The old railML property 'ocpStationRef' has been set to Browsable = false in C#, to HIDE IT from users.
	Do NOT try to assign values to it (this is possible even if it does not show up in RC-ManageProperties).
	Instead, use our own 'ocpStationReference' property, which expects a string.
=========================================================================================================-->
    <LuaFunction Name="RC__getOcpStationReference()" ReturnType="ObjRef"
		Description="Returns an object reference for the current Operation Control Point (OCP) area, or nil if not contained in any (visible) OCP area." >
        <Constructor>ObjRef RC__getOcpStationReference()</Constructor>
		<Formula>
			function RC__getOcpStationReference()
				local OcpAreas = RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				return getCollectionLength(OcpAreas) == 0 and "" or OcpAreas[0] --a GUID string.
			end
        </Formula>
    </LuaFunction>



	<LuaFunction Name="RC__scale()" ReturnType="Vector2D" 
			HideFromUser="false" 
			Description="Scales a 2D vector intended for 1:1 drawing scale into the corresponding vector for the current drawing scale." >
		<Constructor>{Double,Double} RC__scale([Double offsetLateral [,Double offsetAlong]])</Constructor>
		<Formula>
			function RC__scale( offsetLateral, offsetAlong )
				scale = DocumentData.Document.Database.Cannoscale.Scale --CAD system's annotative scale
				LateralOffset = (LateralOffset or 0)/scale
				LongitudinallOffset = (LongitudinallOffset or 0)/scale
				worldOffsetX,worldOffsetY = RC__getWcsVectorFromAcsVector(LateralOffset,LongitudinallOffset)
				return { SymbolOffset.X + worldOffsetX, SymbolOffset.Y + worldOffsetY }
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__assessDerogation()" ReturnType="Enumeration"
		Description="Checks object model check attributes for warnings and errors, sets the derogation state accordingly to [ Normed | Deviating | Requested | Granted]." >
		<Constructor>Enumeration RC__assessDerogation()</Constructor>
		<Formula>
			function RC__assessDerogation()
				--The Derogation state variable influences the SymbolFrame function.
				--Warnings do not affect the derogation state, only errors do:
				errors = LuaExpressions:filter(function(x) return x.IsModelCheck and x.Symbol == "_error" end)
				d = getPropertyValue("Derogation") --Read property, do not refresh the entire object
				if errors.Count == 0 then
					if d == "DEVIATING" then
						return "NORMED" --Problem has disappeared
					else
						return d --No change if already manually set
					end
				else
					if d == "REQUESTED" or d == "GRANTED" then
						return d --No change if already manually set
					else
						return "DEVIATING" --Change state to warn user that a fix or a derogation is needed
					end
				end
			end
		</Formula>
	</LuaFunction>



<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>

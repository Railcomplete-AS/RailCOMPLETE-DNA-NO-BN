<!--========================================================================================================

    NO-BN-General-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml"/>.

	Copyright (c) 2015-2024 Railcomplete AS, Norway, NO916118503
	
=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
    RC general and railway-independent Lua
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
	<LuaFunction Name="RC__getDnaVersion()" ReturnType="String"
		Description="Returns a collection of objects connected through the specified relation, and the number of related objects found. Source object and visibility are optional arguments.">
		<Constructor>int RC__getDnaVersion(double x)</Constructor>
		<Formula>
			function RC__getDnaVersion()
				return DocumentData.DnaIri:match("^(.-);.-$") .."-".. DocumentData.DnaIri:match(".+;(.+)$")
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__toInt()" ReturnType="Int"
		Description="Returns an integer from an integer or floating-point input.">
		<Constructor>int RC__toInt(double x)</Constructor>
		<Formula>function RC__toInt(x) return string.format("%.0f",x) end</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__TextAttributePosition()" ReturnType="Vector2D" 
			HideFromUser="false"
			Description="Returns a World Coordinate System offset vector in the current drawing scale for a text attribute. Input coordinates provide the acsX = lateral offset (positive to the right side of the object's alignment) and the acsY = longitudinal offset (positive in the direction of increasing mileages), both stated for drawing scale 1:1 (1:1000).">
		<Constructor>{Double ACS.X,Double ACS.Y} RC__TextAttributePosition(Double LateralOffset = 0, Double LongitudinalOffset = 0)</Constructor>
		<Formula>
			function RC__TextAttributePosition(LateralOffset, LongitudinalOffset)
				local scale = DocumentData.Document.Database.Cannoscale.Scale --CAD system's annotative scale
				LateralOffset = (LateralOffset or 0)/scale
				LongitudinalOffset = (LongitudinalOffset or 0)/scale
				return RC__getWcsVectorFromAcsVector((RightSided and 1 or -1) * LateralOffset, LongitudinalOffset)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__TextAttributeRotation()" ReturnType="String"
			Description="Returns the rotation of the text element in the world coordinate system. The input argument specifies the angle between the tangent direction of the object axis and the axis of the text. The default value is -90 decimal degrees.">
		<Constructor>DecimalDegrees RC__TextAttributeRotation(Double RelativeAngle = -90)</Constructor>
		<Formula>
			function RC__TextAttributeRotation(RelativeAngle)
				return math.deg(AlignmentTangent) + (RelativeAngle or -90.0)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngleFromDir()" ReturnType="Double"
		Description="Returns the angle in Decimal Degrees corresponding to the given direction [up | down | both | none | unknown]. 'Direction' and 'Rightsided' are optional arguments.">
		<Constructor>Double RC__getAngleFromDir([LaxDirection Direction = InheritedDirection [, Boolean RightSided = false]])</Constructor>
		<Formula>
			function RC__getAngleFromDir(d,rs)
				if d == nil then
					d = dir
					rs = RightSided
				elseif rs == nil then
					rs = false
				end
				if dir == 'up' then return 0
				elseif dir == 'down' then return 180
				elseif dir == 'both' then return rs and -90 or 90
				elseif dir == 'none' then return rs and 90 or -90 
				elseif dir == 'unknown' then return 45 
				else return 45, _info("Bad direction '"..d.."'.")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getMileageFromRelatedObject()" ReturnType="Double"
		Description="Returns the mileage for the projection of the related object onto the calling object's own alignment. Source object is an optional argument.">
		<Constructor>Double RC__getMileageFromRelatedObject(String RelationName [,Reference SourceObject = this])</Constructor>
		<Formula>
			function RC__getMileageFromRelatedObject(RelationName,Source)
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Mileage"),_warning, _info("Missing relation name in function call.")
				end
				local r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Mileage"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getLateralOffsetFromRelatedObject()" ReturnType="Double"
		Description="Returns the distance to alignment for the projection of the related object onto the calling object's own alignment. Source object is an optional argument.">
		<Constructor>Double RC__getLateralOffsetFromRelatedObject(String RelationName [,Reference SourceObject = this])</Constructor>
		<Formula>
			function RC__getLateralOffsetFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("LateralOffset"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("LateralOffset"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("LateralOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("LateralOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getVerticalOffsetFromRelatedObject()" ReturnType="Double"
		Description="Returns the relative elevation above for the projection of the related object onto the calling object's own alignment. Source object is an optional argument.">
		<Constructor>Double RC__getVerticalOffsetFromRelatedObject(String RelationName [,Reference SourceObject = this])</Constructor>
		<Formula>
			function RC__getVerticalOffsetFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("VerticalOffset"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("VerticalOffset"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("VerticalOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("VerticalOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngularOffsetFromRelatedObject()" ReturnType="Double"
		Description="Returns the angular offset for the projection of the related object onto the calling object's own alignment. Source object is an optional argument.">
		<Constructor>Double RC__getAngularOffsetFromRelatedObject(String RelationName [,Reference SourceObject = this])</Constructor>
		<Formula>
			function RC__getAngularOffsetFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("AngularOffset"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("AngularOffset"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDirFromRelatedObject()" ReturnType="Double"
		Description="Returns the direction (Dir) from related object. Source object is an optional argument.">
		<Constructor>Double RC__getDirFromRelatedObject(String RelationName [,Reference SourceObject = this])</Constructor>
		<Formula>
			function RC__getDirFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Dir"),_warning, _info("Missing relation name in function call.")
				end
				r,n = getRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Dir"), _info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].dir, _info("Direction (Dir) deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("Direction (Dir) deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getWcsVectorFromAcsVector()" ReturnType="String"
		Description="Converts an Alignment Coordinate System (ACS) 2D vector {acsX,acsY} = {LateralOffset,LongitudinalOffset} into a World Coordinate System (WCS) 2D vector. An angle in radians can be given instead of using the default, the object's own alignment's tangent direction.">
		<Constructor>{Double,Double} RC__getWcsVectorFromAcsVector(acsX, acsY, AlongAxisWcsAngleInRadians = this.AlignmentTangent)</Constructor>
		<Formula>
			function RC__getWcsVectorFromAcsVector(acsX,acsY,AlongAxisWcsAngleInRadians)
				--WCS = World Coordinate System, the CAD system's underlying absolute Cartesian coordinate system (XY-plane).
				--ACS = "Alignment Coordinate System", a basic RailCOMPLETE concept:
				--	Argument acsX = Lateral offset to the right, perpendicular to the object's alignment axis.
				--	Argument acsY = Along offset in the direction of increasing distAlong, along the object's alignment axis.
				--	Optional argument AlongAxisWcsAngleInRadians = angle in Decimal Degrees between WCS East (X-axis) and the alignment's tangent direction.
				local angle = AlongAxisWcsAngleInRadians or AlignmentTangent
				return  acsX*math.sin(angle) + acsY*math.cos(angle), -acsX*math.cos(angle) + acsY*math.sin(angle)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__identify()" ReturnType="String"
		Description="Returns the object's name if non-empty, or its code if non-empty, otherwise returns its ID. Addresses the calling object if no object reference is given.">
		<Constructor>String RC__identify(Reference obj = this)</Constructor>
		<Formula>
			function RC__identify(obj)
				obj = obj or this
				if type(obj) ~= "userdata" then
					return "ERROR: RC__identify() called with a bad argument type '"..type(obj).."', an objRef was expected."
				end
				local objName = obj:getPropertyValue("name")
				local objCode = obj:getPropertyValue("code")
				local objId = obj:getPropertyValue("id")
				if objName ~= nil and objName ~= "" then return objName
				elseif objCode ~= nil and objCode  ~= "" then return objCode
				else return tostring(objId)
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isNan()" ReturnType="Boolean"
		Description="Returns true if input value is NaN (not a number), otherwise returns false.">
		<Constructor>Boolean RC__isNan(Double value)</Constructor>
		<Formula>function RC__isNan(x) return x ~= x end</Formula>
	</LuaFunction>


	
	<!-- Special sub() pattern control characters are introduced with a byte in the range from 128 to 191, followed by a second byte that gives the  -->
	<!-- actual character, in combination with the first character. -->
	<!-- ^ anchors to start of string. \nnn means "byte contents nnn in decimal". * means "zero or more occurrences". $ means "pattern is anchored to end of string". -->
	<!-- RC__sub("skjØrteMåLET",9) == "åLET" -->
	<!-- RC__sub("skjØrteMåLET",3) == "jØrteMåLET" -->
	<!-- RC__sub("skjØrteMåLET",12) == "T" -->
	<!-- RC__sub("skjØrteMåLET",13) == "" -->
	<!-- RC__sub("skjØrteMåLET",1,1) == "s" -->
	<!-- RC__sub("skjØrteMåLET",4,3) == "" -->
	<!-- RC__sub("skjØrteMåLET") == "skjØrteMåLET" -->
	<!-- RC__sub("") == "" -->
	<!-- RC__sub() == "" -->
	<LuaFunction Name="RC__sub()" ReturnType="String"
		Description="Returns a substring of the input string, starting with its i-th multibyte letter and ending with its j-th multibyte letter (the built-in Lua method sub() will treat a string just as an array of individual bytes). By default, i=1 and j=i.">
		<Constructor>String RC__sub(String s [,Int i [,Int j]])</Constructor>
		<Formula>
			function RC__sub(s,i,j)
				return s, _info("*** Function RC__sub(String s [,Int i [,Int j]]) has not been implemented yet"),_warning
			end
        </Formula>
	</LuaFunction>



	<LuaFunction Name="RC__round()" ReturnType="String"
		Description="Rounds floating point input x to p [-6..6] decimal places. Default precision is 0 decimals.">
		<Constructor>Double RC__round(Double x, Int p = 0)</Constructor>
		<Formula>
			function RC__round(x,p) 
				if math.abs(x) == math.huge then return x end --plus/minus Inf
				if p == nil then p = 0 end
				p = math.floor(p)
				if p &lt; -6 or p &gt; 6 then
					return "Precision ["..p.."] must be from -6 to 6, cannot format value ["..x.."]",_warning
				else
					x = string.format("%."..p.."f",x)
				end
				return tonumber(x)
			end
       </Formula>
	</LuaFunction>

  
  
	<LuaFunction Name="RC__getNearestSnapDistance()" ReturnType="String"
		Description="Returns nearest multiple of step size. Default step size is 3. E.g., '4.51' => '6' and '-7.49' => '-6'.">
		<Constructor>Double RC__getNearestSnapDistance(Double x, Double stepSize = 3])</Constructor>
		<Formula>
			function RC__getNearestSnapDistance(x,stepSize) 
				if stepSize == nil then 
					if x == nil then
						return RightSided and 1e-3 or -1e-3,_warning
					else
						stepSize = 3
					end
				end
				stepSize = math.floor(math.abs(stepSize))
				if stepSize == 0 then
					return RightSided and 1e-3 or -1e-3
				else
					local y = stepSize * math.floor((x / stepSize) + 0.5)
					return y == 0 and (RightSided and 1e-3 or -1e-3) or y
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isMemberOf()" ReturnType="Boolean" 
		Description="Returns true if table/collection/dictionary contains item. The item may be part of a numbered Lua sequence {2,3,5,7,11} or a value in a key/value pair {x=1,y=1,z=2,t=3,u=5}. Advice: When looking for objects, look for its id property item.id (a text string) rather than an object reference, as objects may be relocated in memory for each Lua execution.">
		<Constructor>Boolean RC__isMemberOf(Table t, Item item)</Constructor>
		<Formula>
			function RC__isMemberOf(t,item)
				if type(t) == "table" then
					-- A genuine Lua table, convert it to RailCOMPLETE/C# collection object (deleting the keys from key/value pairs):
					t = getCollectionFromTable(t)
				end
				--Collections respond correctly to the '.Count' attribute:
				for i = 0, t.Count-1 do
					if type(item) == "string" or type(item) == "number" then
						if t[i] == item then
							return true
						end
					elseif item.id then
						if t[i].id == item.id then
							return true
						end
					end
				end
				return false
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__SortedNumberCollection()" ReturnType="Table"
		Description="Returns a sorted table (indexed 1,2,...).">
		<Constructor>table RC__SortedNumberCollection(table t)</Constructor>
		<Formula>
			function RC__SortedNumberCollection(t)
				local u,v,n,i,j,k,lo
				if t == nil then return nil,_error end
				if type(t) ~= type({}) then return '***',_warning end
				t = getCollectionFromTable(t)
				--Insertion sort, ok for small tables. TODO: Implement QuickSort for larger tables.
				u = {}
				v = {}
				n = 0
				while t[n+1] do
					n = n + 1
					table.insert(u,t[n])
				end		
				for i = 1, n do
					lo = math.huge
					for j = 1, n-i+1 do
						if u[j] &lt; lo then 
							lo = u[j]
							k = j 
						end
					end
					table.insert(v,table.remove(u,k)) --insert smallest number from u into v
				end
				return v
			end 
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__getDistance2D()" ReturnType="Double"
		Description="Returns the Euclidian distance in the XY plane between inputs p1 and p2 (point objects or Point3D), each being geoCoord or table {['X']=x,['Y']=y}. p2 is by default the calling object. Z's are ignored.">
		<Constructor>Double RC__getDistance2D(Point p1, Point p2 = this)</Constructor>
		<Formula>
			function RC__getDistance2D(p1,p2) 
				local x1,x2,y1,y2
				if p1 == nil then 
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					--Ordinary RailwayPlacedObject:
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
				elseif p1.X then 
					--Point3D:
					x1 = p1.X
					y1 = p1.Y
				else
					return 0,_warning, _info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					--Ordinary RailwayPlacedObject:
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
				elseif p2.X then
					--Point3D:
					x2 = p2.X
					y2 = p2.Y
				else
					return 0,_warning, _info("Second point has no X coordinate.")
				end
				return math.sqrt((x2-x1)^2 + (y2-y1)^2)
			end
        </Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getDistance3D()" ReturnType="Double"
		Description="Returns the Euclidian distance in XYZ space between inputs p1 and p2 (point objects or Point3D), each being geoCoord or table {['X']=x,['Y']=y,['Z']=z}. p2 is by default the calling object. Z's are 0 if missing.">
		<Constructor>Double RC__getDistance3D(Point p1, Point p2 = this)</Constructor>
		<Formula>
			function RC__getDistance3D(p1,p2) 
				local x1,x2,y1,y2,z1,z2
				-- This code will work both for railML geoCoord entities and for tables using "X", "Y" and "Z" as indices. 
				if p1 == nil then
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
					z1 = p1.geoCoord.Z
				elseif p1.X then 
					x1 = p1.X
					y1 = p1.Y
					z1 = p1.Z == nil and 0 or p1.Z
				else
					return 0,_warning, _info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
					z2 = p2.geoCoord.Z
				elseif p2.X then 
					x2 = p2.X
					y2 = p2.Y
					z2 = p2.Z == nil and 0 or p2.Z
				else
					return 0,_warning, _info("Second point has no X coordinate.")
				end
				return math.sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)
			end
        </Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getAreasOfVariant()" ReturnType="Collection of RcArea"
		Description="Returns a count and a collection of visible areas of the given variant, enclosing the object.">
        <Constructor>{Int, Collection of RcArea} RC__getAreasOfVariant(String areaVariantName, String guidString = this.Id)</Constructor>
        <Formula>
			function RC__getAreasOfVariant(areaVariantName, guidString)
				local obj = guidString and getObjectFromId(guidString) or this
				local areas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:match(areaVariantName) end)
				return areas.Count,areas
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
    RC common Lua, general railway-specific issues, present in any railway administration
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
<!--========================================================================================================
	The old railML property 'ocpStationRef' has been set to Browsable = false in C#, to HIDE IT from users.
	Do NOT try to assign values to it (this is possible even if it does not show up in RC-ManageProperties).
	Instead, use our own 'OcpStationReference' property, which expects a string.
=========================================================================================================-->
    <LuaFunction Name="RC__getOcpStationReference()" ReturnType="ObjRef"
		Description="Returns an object reference for the current Operation Control Point (OCP) area, or nil if not contained in any (visible) OCP area.">
        <Constructor>ObjRef RC__getOcpStationReference()</Constructor>
		<Formula>
			function RC__getOcpStationReference()
				local OcpAreas = RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				return getCollectionLength(OcpAreas) == 0 and "" or OcpAreas[0] --a GUID string.
			end
        </Formula>
    </LuaFunction>



	<LuaFunction Name="RC__scale()" ReturnType="{Double,Double}" 
			HideFromUser="false" 
			Description="Scales a 2D vector intended for 1:1 drawing scale into the corresponding vector for the current drawing scale.">
		<Constructor>{Double,Double} RC__scale(Double LateralOffset = 0, Double LongitudinalOffset = 0)</Constructor>
		<Formula>
			function RC__scale( LateralOffset, LongitudinalOffset )
				local scale = DocumentData.Document.Database.Cannoscale.Scale --CAD system's annotative scale
				LateralOffset = (LateralOffset or 0)/scale
				LongitudinalOffset = (LongitudinalOffset or 0)/scale
				local wcsX,wcsY = RC__getWcsVectorFromAcsVector(LateralOffset,LongitudinalOffset)
				return { SymbolOffset.X + wcsX, SymbolOffset.Y + wcsY }
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__assessDerogation()" ReturnType="Enumeration"
		Description="Checks object model check attributes for warnings and errors, sets the derogation state accordingly to [ Normed | Deviating | Requested | Granted].">
		<Constructor>Enumeration RC__assessDerogation()</Constructor>
		<Formula>
			function RC__assessDerogation()
				--The Derogation state variable influences the SymbolFrame function.
				--Warnings do not affect the derogation state, only errors do:
				local errors = LuaExpressions:filter(function(x) return x.IsModelCheck and x.Symbol == "_error" end)
				local d = getPropertyValue("Derogation") --Read property, do not refresh the entire object
				if errors.Count == 0 then
					if d == "DEVIATING" then
						return "NORMED" --Problem has disappeared
					else
						return d --No change if already manually set
					end
				else
					if d == "REQUESTED" or d == "GRANTED" then
						return d --No change if already manually set
					else
						return "DEVIATING" --Change state to warn user that a fix or a derogation is needed
					end
				end
			end
		</Formula>
	</LuaFunction>



<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>

<!--========================================================================================================

    NO-BN-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml" />.

	(c) Railcomplete AS, Norway, 2015-2021. All rights reserved.

=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
	'NOBN__xxx': NOBN Lua functions not related to railways in particular.
=========================================================================================================-->
	<LuaFunction Name="NOBN__setSymbolFrame()" ReturnType="String"
		Description="Checks object model check attributes for warnings and errors, turns on the corresponding symbol frame (_error/_warning/[no frame])." >
		<Constructor>String NOBN__setSymbolFrame()</Constructor>
		<Formula>
			function NOBN__setSymbolFrame()
				-- More symbol frame types may be available - see the appropriate Style Definitions file.
				_language = 2 -- 1:English, 2:Norwegian, 3:French, 4:German
				_frames = { 
					UNFINISHED	= { "Unfinished",			"Uferdig",				"Incomplet",			"Unvollständig"			},
					HISTORIC	= { "Historic",				"Historic",				"Historique",			"Historisch"			},
					ERROR		= { "Error",				"Error",				"Erreur",				"Fehler"				},
					WARNING		= { "Warning",				"Warning",				"Avertissement",		"Warnung"				},
					SECTION_TAG	= { "section",				"avsnitt",				"zone",					"Abschnitt"				},
					SEGMENT_TAG = { "Segment",				"Segment",				"Segment",				"Segment"				},
					SECTION		= { "SymbolFrame-R2.75",	"Symbolramme-R2.75",	"",						""						}
				}
				--Priority: Show HISTORIC then UNFINISHED then ERROR then WARNING then OTHERs then NO_FRAME
				-- By convention, historic layers have names starting with a double 'at' character '@@':
				if (layer:sub(1,2) == '@@') then
					return _frames.HISTORIC[_language]
				end
			
				t = _frames["UNFINISHED"][_language]
				if tostring(code):upper():match(t:upper()) or tostring(name):upper():match(t:upper()) then 
					return t
				end
			
				--Check for errors or warnings:
				modelChecks = LuaExpressions:filter(function(x) return x.IsModelCheck end)
				if (modelChecks:filter(function(x) return x.Symbol == "_error" end).Count &gt; 0) then 
					return _frames.ERROR[_language]
				elseif (modelChecks:filter(function(x) return x.Symbol == "_warning" end).Count &gt; 0) then
					return _frames.WARNING[_language]
				end
			
				--Deal with axle counter special section objects (the layer name will depend on the DNA in use):
				if RcType:upper():match(_frames.SECTION_TAG[_language]:upper()) then 
					return _frames.SECTION[_language]
				end
			
				--Deal with characteristic point special section objects (the layer name will depend on the DNA in use):
				if RcType:upper():match(_frames.SEGMENT_TAG[_language]:upper()) then 
					return _frames.SECTION[_language]
				end
			
				--Nothing recognised:
				return "" --no frame
			end
		</Formula>
	</LuaFunction>

	

<!--========================================================================================================
	'NOBN_com_xxx': NOBN Lua functions common to two or more railway disciplines.
=========================================================================================================-->


	<LuaFunction Name="NOBN_com_assistAssignEarthingAlignment()" ReturnType="AlignmentRef"
		Description="Suggests an earthing alignment reference for an object, based on its RcType, its Variant and its surroundings. The function assumes that rails of RcType 'JBTKO_SKI Enkeltskinne kjørekant og isolasjon' are present and have been divided already into insulated and non-insulated sections." >
        <Constructor>AlignmentRef NOBN_com_assistAssignEarthingAlignment([ObjRef obj])</Constructor>
		<Formula>
function NOBN_com_assistAssignEarthingAlignment(obj)
	--TODO: Consider replacing "Red/Green" filter with a downwards search for track insulation with railML property 'left', 'right', 'both', 'none' (in associated track).
	if obj == nil then obj = this end

	--Gauge tolerance when looking for rails belonging to the same track:
	gaugeTolerance = 0.030 --[m]
	--If not too far away, we prefer a dedicated earth rail over double insulated track, where you should consider not earthing to both rails:
	railDistanceTolerance = 6.000  --[m]

	if EarthingMethod == "None" then 
		return

	elseif EarthingMethod == "Unknown" then 
		return _info("UNFINISHED - Earthing method is Unknown, cannot deduce EarthingAlignment.")
		
	elseif EarthingMethod == "Rail" then
		r = getClosestAlignments("JBTKO_SKI Enkeltskinne kjørekant og isolasjon",obj):filter(function (x) return x:getPropertyValue("Color"):upper() == "RED" end)
		if getAlignmentInfo(r[0].id,obj).NormalProjectionExists then
			--Find distance sideways to closest insulated rail:
			d = getAlignmentInfo(r[0].id,obj).DistanceToAlignment
		else
			--No normal projection exists onto insulated rail, so look for  distance to closest start/end of closest insulated rail:
			d = math.min(RC__getDistance2D(r[0].RcAlignment.StartPoint,obj),RC__getDistance2D(r[0].RcAlignment.EndPoint,obj))
		end
		if math.abs(d) &lt;= railDistanceTolerance then
			--If distance to insulated rail is reasonably short, then use it now...
			return r[0]
		else 
			--...otherwise, check if the two closest *un*insulated rails belong to the same track, asuuming both are (through use of impedances) carrying return current:
			--Btw, this proceudre fails if the object is between two tracks where insulated rail distances are just above the tolerance, so that the two closest 
			--return rails belong to two *different* railway tracks.
			r = getClosestAlignments("JBTKO_SKI Enkeltskinne kjørekant og isolasjon"):filter(function (x) return getAlignmentInfo(x.id).NormalProjectionExists and x.color:upper() == "GREEN" end)
			n = getCollectionLength(r)
			d0 = getAlignmentInfo(r[0].id,obj).DistanceToAlignment
			d1 = getAlignmentInfo(r[1].id,obj).DistanceToAlignment
			if math.abs(math.abs(d0-d1) - r[0].AlignmentSystem.AlignmentGauge) &lt; gaugeTolerance then
				--Pick closest un-insulated rail, although it is 'bad taste' if we thereby end up
				--with objects earthed to both rails within one double-insulated track circuit:
				return r[0]
			else
				return _info("Search for nearby rails suitable for protective earthing failed (i.e., rails of type 'JBTKO_SKI Enkeltskinne kjørekant og isolasjon', carrying return current).")
			end
		end
		r = getClosestAlignments("JBTKO_SKI Enkeltskinne kjørekant og isolasjon",obj):filter(function (x) return x:getPropertyValue("Color"):upper() == "RED" end)
		return r[0]

	elseif EarthingMethod == "Wire" then 
		r = getClosestAlignments("JBTEH_JOR Jordleder",obj)
		return r[0]
		
	elseif EarthingMethod == "Object" then 
		--Just return - and let similar Lua code for the 'EarthingObject' reference property do the job:
		return
	end
end
        </Formula>
    </LuaFunction>

	<LuaFunction Name="NOBN_com_assistAssignEarthingObject()" ReturnType="ObjectRef"
		Description="Suggests an earthing object reference for an object, based on its RcType, its Variant and its surroundings. The function assumes that there is an object nearby that can offer protective earth." >
        <Constructor>AlignmentRef NOBN_com_assistAssignEarthingObject([ObjRef obj])</Constructor>
		<Formula>
function NOBN_com_assistAssignEarthingObject(obj)
	if obj == nil then obj = this end
	local earthingConnectionMaxLength = 10 --[m]

	if obj.EarthingMethod == "None" then 
		return _void
	
	elseif obj.EarthingMethod == "Unknown" then 
		return _void,_info("UNFINISHED - Earthing method is Unknown, cannot deduce EarthingObject.")
	
	elseif obj.EarthingMethod == "Rail" then
		return _void
	
	elseif obj.EarthingMethod == "Wire" then 
		return _void
	
	elseif obj.EarthingMethod == "Object" then 
		local npo = getNearbyPointObjects2D(earthingConnectionMaxLength,obj):filter
			(function (x)
				local em = x:getPropertyValue("EarthingMethod")
				local ea = x:getPropertyValue("EarthingAlignment")
				local eo = x:getPropertyValue("EarthingAlignment")
				return 
					((em == 'Rail' or em == 'Wire') and (ea and ea ~= obj))
					or
					((em == 'Object') and (eo and eo ~= obj))
			end)
		if getCollectionLength(npo) &gt; 0 then
			return npo[0]
		else 
			return _void,_error,_info("UNFINISHED - Earthing method is Object, but no suitable earth providing objects found.")
		end
		
	else
		-- Should not happen
		return nil,_info("*** ERROR - Bad Earthing Method.")
	end
end
        </Formula>
    </LuaFunction>
		
	<LuaFunction Name="NOBN_com_assistAssignEarthingLabelText()" ReturnType="String"
		Description="Suggests an earthing alignment label text for an object, based on its RcType, its Variant and its surroundings. The function assumes that the object already has a defined EarthingMethod and EarthingAlignment/EarthingObject." >
        <Constructor>String NOBN_com_assistAssignEarthingLabelText([ObjRef obj])</Constructor>
		<Formula>
function NOBN_com_assistAssignEarthingLabelText(obj)
	if obj == nil then obj = this end
	if obj.EarthingMethod == "None" then 
		return ""
	elseif obj.EarthingMethod == "Object" then
		return RC__identify(obj.EarthingObject).." / "..RC__identify(obj)
	elseif obj.EarthingMethod == "Wire" then 
		return RC__identify(obj.EarthingAlignment).." / "..RC__identify(obj)
	elseif obj.EarthingMethod == "Rail" then 
		return RC__identify(obj.EarthingAlignment).." / "..RC__identify(obj)
	elseif obj.EarthingMethod == "Unknown" then 
		return "(?)".." / "..RC__identify(obj)
	else
		return _error,"*** ERROR - Bad Earthing Method ["..obj.EarthingMethod.."]."
	end
end
        </Formula>
    </LuaFunction>

	<LuaFunction Name="NOBN_com_assignEarthingLabelColor" ReturnType="String"
		Description="Assigns the color for the permanent marking tag attached to earthing connector, deduced from the object's discipline." >
        <Constructor>String NOBN_com_assignEarthingLabelColor([ObjRef obj])</Constructor>
		<Formula>
function NOBN_com_assistAssignEarthingLabelColor(obj)
	obj = obj or this
	if obj.Discipline == "Felles" then return 7 --"Hvit"
	elseif obj.Discipline == "Underbygning" then return 7 --"Hvit"
	elseif obj.Discipline == "Overbygning" then return 7 --"Hvit"
	elseif obj.Discipline == "Kontaktledning" then return 1 --"Rød"
	elseif obj.Discipline == "Signal" then return 3 --"Grønn"
	elseif obj.Discipline == "Tele" then return 2 --"Gul"
	elseif obj.Discipline == "Lavspent" then return 5 --"Blå"
	elseif obj.Discipline == "Skilt" then return 7 --"Hvit"
	else 
		return _error,"*** ERROR - Uncrecognized discipline ["..obj.Discipline.."]."
	end
end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="NOBN_com_assistAssignEarthingLabelColor()" ReturnType="String"
		Description="Suggests an earthing alignment label color for an object, based on its discipline." >
        <Constructor>String NOBN_com_assistAssignEarthingLabelColor([ObjRef obj])</Constructor>
		<Formula>
        </Formula>
    </LuaFunction>


	<LuaFunction Name="NOBN_com_assistAssignEarthingPosBias()" ReturnType="Double"
		Description="Suggests an earthing alignment pos bias for an object, based on its earthing method and its surroundings. A non-zero bias moves the 'earthing landing point' along the earthing alignment." >
        <Constructor>Double NOBN_com_assistAssignEarthingPosBias([ObjRef obj])</Constructor>
		<Formula>
function NOBN_com_assistAssignEarthingPosBias(obj)
	if obj == nil then obj = this end
	local offset = 1
	if obj.EarthingMethod == "Rail" then
		if getAlignmentInfo(obj.EarthingAlignment.id).NormalProjectionExists then
			return 0
		else 
			--Move earth connection a little past insulation along insulated rail's tangent direction (at start or end of rail): 
			ps = obj.EarthingAlignment.RcAlignment.StartPoint
			pe = obj.EarthingAlignment.RcAlignment.EndPoint
			ds = RC__getDistance2D(ps,obj)
			de = RC__getDistance2D(pe,obj)
			if ds &lt; de then
				u = obj.EarthingAlignment.RcAlignment.StartTangent
				return ((ps.X-geoCoord.X)*u.X + (ps.Y-geoCoord.Y)*u.Y) > 0 and offset or -offset 
			else
				u = obj.EarthingAlignment.RcAlignment.EndTangent
				return ((ps.X-geoCoord.X)*u.X + (ps.Y-geoCoord.Y)*u.Y) > 0 and offset or -offset 
			end
		end
	end
end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
	Track - general position issues, relative to track alignments, used by all objects.
	See also the lua source files for track objects and track connections.
=========================================================================================================-->
	<LuaFunction Name="NOBN_trk_getLiftFromCant()" ReturnType="Double"
		Description="Returns a track-bound object's Z-coordinate offset above the gradient curve [m], consistent with own alignment's local cant. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument." >
		<Constructor>Double NOBN_trk_getLiftFromCant([_position])</Constructor>
		<Formula>
function NOBN_trk_getLiftFromCant(where)
	--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
	--'where' is a data structure, if present, consisting of .Pos and .Ref
	if where == nil then
		-- can be called from point objects:
		ai = getAlignmentInfo()
	else
		-- can be called from anywhere, including an alignment, as a sampled formula:
	    ai = getAlignmentInfo(where)
	end
	if RcAlignment == nil then 
		-- 'this' is a point object:
		cg = Alignment.AlignmentSystem.CantGauge
		lwc = Alignment.AlignmentSystem.QuickMode3DLiftWithCant
		dta = DistanceToAlignment
	else 
		-- 'this' is an alignment:
		cg = AlignmentSystem.CantGauge
		lwc = AlignmentSystem.QuickMode3DLiftWithCant
		dta = 0.0 --DistanceToAlignment
	end
	if not lwc then 
		return 0.0,_info("Alignment system does not lift with cant.")
	end
	c = ai.Cant
    if c == nil or RC__isNan(c) then
        return 0.0,_info("UNFINISHED - No cant data in alignment, assuming zero cant.")
	elseif c == 0 then
		return 0.0
    else
        -- Cant is measured in millimeter superelevation
        -- Ask alignment system whether cant leads to lift or not:
	    h = c/1000.0 --[m]
		if h &gt; cg then 
			h = cg - 0.001 -- Almost 90 degrees roll...
			msg = "Cant truncated to max, "..RC__round(1000*h).." mm."
		else
			msg = RC__round(1000*h).." mm cant."
		end
		railSeparationXY = math.sqrt(cg^2 - h^2)
		if h == 0.0 then
			return 0.0,_info(msg)
		else
			cr = ai.CantRotation
			if cr == "CCW" then
				-- Right rail lifted above left rail
				return h/2 + h/2 * dta / (railSeparationXY / 2)
			elseif cr == "CW" then
				-- Left rail lifted above right rail
				return h/2 - h/2 * dta / (railSeparationXY / 2)
			else
				return 0.0,_error,_info("Bad cant rotation data ["..CantRotation.."], assuming zero lift.")
			end
		end
	end
end
		</Formula>		
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_trk_getDistanceToAlignmentFromCantAndTrackPlaneDistance()" ReturnType="Double"
		Description="Returns a track-bound object's 2D distance to the alignment axis (IFC:gradient curve) as a function of its track plane distance to own model insertion axis. 'TrackPlaneDistance' is by default set to half of the rail separation (track gauge). If called from an alignment object, the reserved identifier '_position' holding a {Pos, Ref} must be provided as an input argument." >
		<Formula>
function NOBN_trk_getDistanceToAlignmentFromCantAndTrackPlaneDistance(TrackPlaneDistance,where)
	local cg
	if RcAlignment == nil then 
		-- 'this' is a point object:
		cg = Alignment.AlignmentSystem.CantGauge
	else 
		-- 'this' is an alignment:
		cg = AlignmentSystem.CantGauge
	end
	if TrackPlaneDistance == nil then
		--No specific distance as input, use side of track and place on rail:
		TrackPlaneDistance = RightSided and cg/2.0 or -cg/2.0
	end
	--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
	--'where' is a data structure, if present, consisting of .Pos and .Ref
	if where == nil then
		-- Assume function has been called from a point object:
		ai = getAlignmentInfo()
	else
	    ai = getAlignmentInfo(where)
	end
	g = ai.Gradient
	h = ai.Cant/1000.0
	if RC__isNan(h) then 
		return TrackPlaneDistance,_info("No cant data in alignment, assuming zero cant.")
	else
		-- Scale track plane distance to alignment with effect of cant:
	 	return TrackPlaneDistance * math.sqrt(1 - (h/cg)^2)
	end
end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_trk_getRollFromCant()" ReturnType="Double"
		Description="Returns a track-bound object's sideways roll [Decimal Degrees], consistent with own alignment's local cant and object direction up/down. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument." >
		<Constructor>Double NOBN_trk_getRollFromCant([_position])</Constructor>
		<Formula>
			function NOBN_trk_getRollFromCant(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				if where == nil then
					-- Assume function was called from a point object:
					ai = getAlignmentInfo()
				else
					-- can be called from anywhere, including an alignment, as a sampled formula:
					ai = getAlignmentInfo(where)
				end
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
				end
				c = ai.Cant
				if c == nil or RC__isNan(c) then
					return 0.0,_info("UNFINISHED - No cant data in alignment, assuming zero cant.")
				elseif c == 0 then
					return 0.0
				else
					-- Cant is measured in millimeter superelevation, with rotation clockwise or counterclockwise in the track's direction
					-- Assume that only one rail is lifted at a time.
					h = c/1000.0
					cr = tostring(ai.CantRotation)
					if  cr:upper() == "CW" then
						return math.asin(h/cg)*(180/math.pi)
					elseif cr:upper() == "CCW" then 
						return -math.asin(h/cg)*(180/math.pi)
					else
						return 90.0,_error,_info("Bad cant rotation data ["..CantRotation.."], assuming 90 degrees roll as a visual warning.")
					end
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_getRollFromCantInterpretedAsDecimalDegrees()" ReturnType="Double"
		Description="Returns a roll angle deduced from an alignment's cant, where Cant is interpreted as decimal degrees and CW/CCW." >
		<Constructor>Double NOBN_com_getRollFromCantInterpretedAsDecimalDegrees([_position])</Constructor>
		<Formula>
			function NOBN_com_getRollFromCantInterpretedAsDecimalDegrees(where)
				--If called to express e.g. a road, or OCS wire clamps or sweeping a contact wire, then '_position' is provided by RC, sampled along the alignment.
				if where == nil then
					ai = getAlignmentInfo()
				else
					ai = getAlignmentInfo(where)
				end
				angleInDecimalDegrees = ai.Cant --  NB! Cant is interpreted as decimal degrees CW/CCW.
				if (RC__isNan(angleInDecimalDegrees)) then
					return 0,_info("UNFINISHED - No cant (to be interpreted as an angle in decimal degrees) data in non-track alignment, assuming zero cant.")
				elseif angleInDecimalDegrees == 0 then
					return 0
				else
					-- Cant is measured in millimeter superelevation, with rotation clockwise or counterclockwise in the track's direction
					-- Assume that only one rail is lifted at a time.
					cr = tostring(ai.CantRotation)
					if  cr:upper() == "CW" then
						return angleInDecimalDegrees
					elseif cr:upper() == "CCW" then 
						return -angleInDecimalDegrees
					else
						return 90.0,_error,_info("Bad cant rotation data ["..CantRotation.."], assuming 90 degrees roll as a visual warning.")
					end
				end
			end
		</Formula>
	</LuaFunction>


	
	<!-- TODO Lage funksjoner for 3D Offset og Rotation slik at de benytter _position og kan brukes i linjers 3D-eksport også. -->
	<LuaFunction Name="NOBN_trk_getPitchFromGradient()" ReturnType="Double"
		Description="Returns a track-bound object's pitch [decimal degrees], consistent with own alignment's local gradient, and object orientation up/down/both/none. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument." >
		<Constructor>Double NOBN_trk_getPitchFromGradient([_position])</Constructor>
		<Formula>
function NOBN_trk_getPitchFromGradient(where)
	--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC, sampled along the alignment.
	if where == nil then
		g = getAlignmentInfo().gradient
	else
	    g = getAlignmentInfo(where).gradient 
	end
    if RC__isNan(g) then
        return 0.0,_info("No gradient data in alignment, assuming zero gradient.")
    else
        return math.atan(g/1000)*(180/math.pi)
    end
end
		</Formula>
	</LuaFunction>
	
	
	
    <LuaFunction Name="NOBN_trk_getYawFromDir()" ReturnType="Double"
		Description="Returns object's 3D rotation [DD] from its direction property 'dir' (up/down/none/both) and side of alignment, as seen in the direction of increasing mileage. If a non-zero rotation [DD] is provided, then the rotation takes precedence over the 'dir' property. Balises are a special case, assuming cable extends to the right from the 3D model, a slight leftside bias turns the balise around so the cable extends at the left side of the track." >
        <Constructor>Double NOBN_trk_getYawFromDir([Double rotation])</Constructor>
		<Formula>
function NOBN_trk_getYawFromDir(rotation)
	d = getPropertyValue("dir") --Strip off _symbol and _info() if any, get just the plain string value
	if RcType == "JBTSA_ATB Balise" then 
		--Special case: Place balise slightly to the right of center track to keep the cable extending to the right
		--We assume that all balises have cable extending to the right when seen in the 3D object's 'up' direction
		--(the cable will then be best protected for left-handed normal driving on double track lines).
		if AngularOffset == nil then 
			return RightSided and 0.0 or 180.0
		else	
			return AngularOffset + (RightSided and 0.0 or 180.0)
		end
	end
	if rotation == nil and AngularOffset == nil then
		-- No argument given, and no standard property 'AngularOffset' exists for the current object
		if d == 'up' then
			return 0.0
		elseif d == 'down' then
			return 180.0
		elseif d == 'both' then
			return RightSided and -90.0 or 90.0
		elseif d == 'none' then
			return RightSided and 90.0 or -90.0
		else --d == unknown':
			return 45.0,_warning,_info("EnableDirectionSetting is 'unknown', cannot compute yaw, assuming 45 degrees as a visual warning.")
		end
	else
		--Modify 'dir' with extra rotation:
		if rotation == nil then
			--No arg given, use object's own AngularOffset:
			rotation = AngularOffset
		else 
			if math.abs(rotation) &lt; 4e-4 then 
				rotation = 0.0 --remove small inaccuracies
			end
		end
		if d == 'up' then
			return rotation,_info("'up' with "..rotation.." degrees extra rotation.")
		elseif d == 'down' then
			return 180.0+rotation,_info("'down' with "..rotation.." degrees extra rotation.")
		elseif d == 'both' then
			return (RightSided and -90.0 or 90.0) + rotation,_info("'both' with "..rotation.." degrees extra rotation.")
		elseif d == 'none' then
			return (RightSided and 90.0 or -90.0) + rotation,_info("'none' with "..rotation.." degrees extra rotation.")
		else --d == unknown':
			return 45.0,_warning,_info("EnableDirectionSetting is 'unknown', cannot compute yaw, assuming 45 degrees as a visual warning .")
		end
	end
end
		</Formula>
	</LuaFunction>

	
	
<!--========================================================================================================
	Track - Continuations, switches and crossings
=========================================================================================================-->
	<!-- INFO 2019-05-07 CLFEY: OCS Lua functions moved to file for TrackCOnnections / TrackObjects. -->

	
<!--========================================================================================================
	Signaling
=========================================================================================================-->
	<LuaFunction Name="NOBN_sig_getSignalSightingRequirement()" ReturnType="String"
		Description="Returns the sighting requirement according to TRV regulations for signals. Speed is extracted from the object's own alignment using 'getAlignmentInfo().Speed'. If no design speed is found in the object's own alignment, then 130 km/h will be assumed." >
		<Constructor>Double NOBN_sig_getSignalSightingRequirement()</Constructor>
		<Formula>
function NOBN_sig_getSignalSightingRequirement()
	local DesignSpeed = getAlignmentInfo().Speed or 130 --130 km/h assumed if alignment has no design speed available

	if RcType == "JBTSA_SIG ERTMS" then
		-- ERTMS marker board - Fixed 150 m requirement?
		if MarkerBoard == "-" then
			return 150,_info(DesignSpeed.." km/h: 150 m fixed sighting requirement for ERTMS boards.")
		elseif DwarfSignal == "Ja" and MarkerBoard == "-" then
			return 50,_info("50 m fixed sighting requirement during shunting movements (NB! There are rules for sight/stopping distance towards Ss43 as well).")
		end
	
	elseif RcType == "JBTSA_SIG Signal" then
		if not (MainSignal:match("^Hs") or  DistantSignal:match("Ja")) and (DwarfSignal == "Ja" or HighShuntingSignal == "Ja") then
			return 50,_info("50 m fixed sighting requirement during shunting movements (NB! There are rules for sight/stopping distance towards Ss43 as well).")
	
		elseif (MainSignal:match("^Hs") or EndOfTrainRoute == "Ja") and (DistantSignal == "-") then
			-- Ref TRV Signal prosjektering, 2.1.2 "Hovedsignal"
			--NB! If through-signaling is in use, the sighting requirements are reduced to 80 km/h requirements - see TRV change ca 2019.
			if DesignSpeed &gt; 210 then
				return 250,_info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, and 250 m above 210 km/h.")
			else 
				v = math.max(135,math.min(210,DesignSpeed))
				return RC__round(v/3.6 * 4, 0),_info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, max. 250 m above 210 km/h.")
			end

		elseif DistantSignal == "Ja" then 
			-- Ref TRV Signal prosjektering, 2.1.3 "Forsignal"
			v = math.max(40,math.min(130,DesignSpeed))
			return RC__round(v/3.6 * 7, 0),_info(DesignSpeed.." km/h: Min. 78 m distant signal unbroken sighting, 7 seconds from 40 to 130 km/h, max 250 m above 130 km/h.")

		elseif HighShuntingSignal ~= "-" then
			return 50,_info("50 m fixed sighting requirement during shunting movements.")
	
		else
			return 0,_info(DesignSpeed.." km/h: Bad JBTSA_SIG Signal type [RcType="..RcType..", Variant="..(Variant and "(void)" or Variant.."."))
		end

	
	elseif RcType == "JBTSA_SIG PLO-signal" then
		-- Ref TRV Signal prosjektering, 2.1.2 "Hovedsignal"
		if DesignSpeed &gt; 210 then
			return 250,_info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, and 250 m above 210 km/h.")
		else 
			v = math.max(135,math.min(210,DesignSpeed))
			return RC__round(v/3.6 * 4, 0),_info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, max. 250 m above 210 km/h.")
		end

	elseif RcType == "SA-SIG PLO-forsignal" then
		-- Ref TRV Signal prosjektering, 2.1.3 "Forsignal"
		v = math.max(40,math.min(130,DesignSpeed))
		return RC__round(v/3.6 * 7, 0),_info(DesignSpeed.." km/h: Min. 78 m distant signal unbroken sighting, 7 seconds from 40 to 130 km/h, max 250 m above 130 km/h.")

	elseif RcType == "JBTSA_SIG Veisignal" then
		--Signal mot vei
		return 30,_info("30 m fixed sighting requirement for road traffic towards level crossing signal (To be verified!).")

	elseif RcType == "JBTSA_SIG Brusignal/Frostportsignal" then 
		--Samme byggeteknikk som for 3-lys Hs (2 røde blink / 1 hvit blink)
		return 150,_info("150 m fixed sighting requirement for bridge / frost gate signal (To be verified!).")

	elseif RcType == "JBTSA_SIG Togsporsignal" then
		--Ingen spesielle krav, plasseres når lokfører eller ombordansvarlig ikke ser hovedsignal (ikke tillatt i nye anlegg)
		return 50,_info("50 m fixed sighting requirement for Togsporsignal (old type RepHs repeater signal) (To be verified!).")

	else
		return 0,_info(DesignSpeed.." km/h: Bad signal type [RcType="..RcType..", Variant="..(Variant or "(void)").."].")
	end
end
		</Formula>
	</LuaFunction>


	
<!--========================================================================================================
	bnp - Boards 'n poles
=========================================================================================================-->
	<LuaFunction Name="NOBN_bnp_getBoardOffset3dZ()" ReturnType="String"
		Description="Returns the default pole 3D offset Z, i.e. the height of the pole." >
		<Constructor>Double NOBN_bnp_getBoardOffset3dZ()</Constructor>
		<Formula>
function NOBN_bnp_getBoardOffset3dZ()
	-- To be mounted below other board on common pole:
	if Variant:find("Meterangivelse") then return 2.6 --May be placed under 68F
	elseif Variant:find("68F") then return 2.8 --Tilleggshastighet, to be placed under 68

	--To be mounted relatively low on NSI63 optical signal's mast:
	elseif Variant:find("62") then return 2.85 --Ugyldighetssignal på standard Bane NOR signalmast alternativ 2
	elseif Variant:find("72") then return 2.45 --FJS begynner/slutter
	elseif Variant:find("73") then return 2.45 --Rasvarsling
	elseif Variant:find("F-ATC") or Variant:find("D-ATC") then return 2.9

	--To be mounted on front/top of optical light signal's sunscreen:
	elseif Variant:find("60E") then return 5.80 --ATC Varsel. Remember to adjust Offset3d.Y as well.

	--Close to track, low placement, with pole:
	elseif Variant:find("Bevegelig kryss") then return 0.5 --Short vertical pole close to track
	elseif Variant:find("69") then return 1.5 --Temporary speed restriction, to be mounted with horizontal pole to track/sleeper

	--Close to track, low placement, no pole:
	elseif Variant:find("Baliseskilt") then return 0.0 --Mounted on platform element's side towards track, at A-balise

	--May be hanging from yoke, othwerwise on own pole:
	elseif Variant:find("Spornummer") then return Yokemounted and -1 or 3.5
	-- TODO elseif Variant:find("E34") then return Yokemounted and -1 or 3.5 --ERTMS Stedsskilt
	elseif Variant:find("E35") then return Yokemounted and -1 or 3.5 --ERTMS Stoppskilt

	--To be read by train driver sitting in train, AND by walking people:
	elseif Variant:find("1000V") then return 2.5
	elseif Variant:find("kjedebrudd") then return 2.5

	--To be read by walking people:
	elseif Variant:find("Nødtelefon") then return 2.00
	elseif Variant:find("Stopp se og lytt") then return 2.00 --Skilt langs bilvei, for mennesker
	elseif Variant:find("Arbeidsområde") then return 2.02 --Tenkt montert på et NSI hovedsignal

	-- High relative Elevations, no pole:
	elseif Variant:find("75B") then return 0.0 --Old km board type, directly on tunnel wall (high RelativeElevation)
	elseif Variant:find("Rømningsavstand") then return 0.0 --Escape route distance / direction board, directly on tunnel wall

	else 
		return 3.5
	end
end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_bnp_getPoleRoutingDefaultValue()" ReturnType="String"
		Description="Returns the default pole setting for the board in question, from {'none','vertical','horizontal'}." >
		<Constructor>enum {'None','Vertical','Horizontal'} NOBN_bnp_getPoleRoutingDefaultValue()</Constructor>
		<Formula>
function NOBN_bnp_getPoleRoutingDefaultValue()
	if Variant:find("Baliseskilt")
		or Variant:find("60E")
		or Variant:find("62")
		or Variant:find("67E")
		or Variant:find("68F")
		or Variant:find("70")
		or Variant:find("72A")
		or Variant:find("72B")
		or Variant:find("73")
		or Variant:find("Arbeidsområde")
		or Variant:find("138") --Trafikkskilt Andreaskors langs bilvei ved PLO, festes på lyssignal mot vei
	then 
		return "None"

	elseif variant:find("69") then
		return "Horizontal" --Fixed with temporary bracket to closest rail/sleeper

	else 
		return "Vertical"
	end
end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_bnp_getBoardSightingRequirement()" ReturnType="String"
		Description="Returns the sighting requirement according to TRV regulations for vegetation clearance towards boards. Speed is extracted from the object's own alignment using getAlignmentInfo().Speed." >
		<Constructor>Double NOBN_bnp_getBoardSightingRequirement()</Constructor>
		<Formula>
function NOBN_bnp_getBoardSightingRequirement()
	local DesignSpeed = getAlignmentInfo().Speed or 130 --130 km/h assumed if alignment has no design speed available

	if 	   Variant:find("Baliseskilt")
		or Variant:find("Arbeidsområde")
		or Variant:find("75C") -- 75C: Hev sporrenser
		or Variant:find("75D") -- 75D: Senk sporrenser
		or Variant:find("60E") --ATC Varsel - Monteres på Fs eller Hs+Fs
		or Variant:find("62") --Ugyldighetsskilt - står alltid sammen med Hs, Fs eller enkelt innkjørsignal
		or Variant:find("64E") --64E: Blå/Hvit Teknisk stolpe
		or Variant:find("67E") --Orienteringssignal dagtid, unngå å gi signal 83 "Tog kommer" mellom kl 22 og 06
		or Variant:find("68F") --Tilleggshastighet underskilt - står alltid sammen med signal 68AB
		or Variant:find("68G") --Krengetoghasighet underskilt - står alltid sammen med signal 68AB
		or Variant:find("101") --ID-skilt av alle typer
		or Variant:find("102") --PIL
		or Variant:find("138") --Trafikkskilt Andreaskors langs bilvei ved PLO, festes på lyssignal mot vei
	then
		--No sighting requirement:
		return 0,_info("No sighting requirement.")

	elseif
		(Variant:find("60") and not Variant:find("60E")) --60ABCD_FGH: ATC skilt
		or variant:find("61") --61ABC: Avstandsskilt 1/2/3 (1000/800/250 meter)
		or variant:find("63") --63AB: Fallviser/Stigningsviser
		or Variant:find("64A") --64A: Grense-innkoblingsstolpe
		or Variant:find("64B") --64B: Seksjoneringsstolpe
		or Variant:find("64C") --64C: Rasvarslingsstolpe
		or Variant:find("64D") --64D: Bremsestolpe
		or Variant:find("65") --65ABCDEFG: KL-skilt
		or Variant:find("66") --66: Togvei slutt
		or variant:find("68A") --69A: Nedsatt hastighet
		or variant:find("68B") --69B: Økt hastighet
		or variant:find("68C") --69C: Avvikende hastighet
		or variant:find("68D") --69D: Markeringsmerke
		or variant:find("69") --69AB: Midlertidig hastighet
		or Variant:find("70") --70: Planovergangsskilt "V"
		or Variant:find("72") --72AB: FJS begynner/slutter
		or Variant:find("73") --73: Rasvarsling
		or Variant:find("74") --74: Toglengdeskilt
		or Variant:find("75A") --75AB: Kilometerskilt, gammel type
		or Variant:find("75B") --75AB: Kilometer, ny type
	then
		-- Ref TRV Underbygning vedlikehold, 2.1.1 "Sikt til signaler og skilt"
		v = math.max(40,math.min(130,DesignSpeed))
		d = RC__round(v/3.6 * 5, 0)
		return d,_info(d.."m required at "..DesignSpeed.." km/h (5 seconds unbroken sighting, min. 56m, max. 181m.")

	elseif		
		--Krav som til dvergsignaler pga kun aktuelle å observere under skifting (40 km/h / 50 meter)
		   Variant:find("51") --51ABCD: Sporvekselsignal, lysreflekterende. A=tilRettspor, B=fraAvvik, C=tilV, D=tilH
		or Variant:find("52") --52ABCD: Sporvekselsignal for kryssporveksel. A=fraVtilH, B=fraHtilV, C=fraVtilV, D=fraHtilH.
		or Variant:find("53") --53: Sporsperresignal, "sporet sperret"
		or Variant:find("54") --54: Sporsperresignal, "sporet fritt"
		or Variant:find("64E") --64E: Dvergsignalstolpe
	then
		return 50,_info("50 m fixed sighting requirement during shunting movements.")

	else
		return 0,_info(DesignSpeed.." km/h: Bad board type [RcType="..RcType..", Variant="..(Variant and "(void)" or Variant.."."))
	end
end
		</Formula>
	</LuaFunction>



<!--========================================================================================================
	ocs - Overhead catenary System Lua formulas (including return current and earthing)
=========================================================================================================-->
	<!-- INFO 2019-05-07 CLFEY: OCS Lua functions moved to file for OcsObjects. -->


<!--========================================================================================================
	sub - Substructure / civil works functions accessible globally
=========================================================================================================-->
	<LuaFunction Name="NOBN_sub_getFoundationCode()" ReturnType="String" 
		Description="Returns the code for a foundation / bolt group / deduced from its associated object (based on RcType and close proximity)." >
		<Constructor>String NOBN_sub_getFoundationCode([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_sub_getFoundationCode(obj)
				local tol = 0.25 --Look for a matching object close to 'obj'
				local function fn(obj,objectTypes,errMsg)
		 			--Check for matching objects in prioritized order.
					local ot,n,i,o
					ot = getCollectionFromTable(objectTypes)
					n = ot.count
					for i=0,n-1 do
						o = getNearbyPointObjects2D(tol,ot[i],obj)
						if getCollectionLength(o) &gt; 0 then return o[0].code end
					end
					return errMsg 
				end
		
				if obj == nil then obj = this end
				if RcType:match("JBTEH_FUN KL%-fundament") then 
					return fn(obj,{"JBTEH_MAS KL-mast","JBTEH_BAR Bardunfeste"},"UNFINISHED - no visible OCS mast or spanner / strecher fastener found at foundation.")
				elseif RcType:match("JBTKU_FUN Signalfundament") then 
					return fn(obj,{"JBTSA_SIG Signal"},"UNFINISHED - no visible signal found at foundation.")
				elseif RcType:match("JBTKU_FUN Apparatskapfundament") then 
					return fn(obj,{"JBTSA_APS Apparatskap"},"UNFINISHED - no visible signal cabinet found at foundation.")
				elseif RcType:match("JBTKU_FUN Telefundament") then 
					return fn(obj,{"TODO: Define telecom objects here :ODOT"},"UNFINISHED - no visible matching telecom object found at foundation.")
				end
			end
		</Formula>
	</LuaFunction> 
		


<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>

<!--========================================================================================================

    NO-BN-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml" />.

	(c) Railcomplete AS, Norway, 2015-2021. All rights reserved.

=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
	'NOBN__xxx': NOBN Lua functions not related to railways in particular.
=========================================================================================================-->
	<LuaFunction Name="NOBN__setSymbolFrame()" ReturnType="String"
		Description="Checks object modelcheck attributes for status symbols warnings and errors, turns on the corresponding symbol frame ([no frame]/_unfinished/_warning/_error)." >
		<Constructor>String NOBN__setSymbolFrame()</Constructor>
		<Formula>
			function NOBN__setSymbolFrame()
				-- More symbol frame types may be available - see the appropriate Style Definitions file.
				_language = 2 -- 1:English, 2:Norwegian, 3:French, 4:German
				_frames = { 
					HISTORIC	= { "Historic",				"Historic",				"Historique",			"Historisch"			},
					UNFINISHED	= { "Unfinished",			"Unfinished",			"Incomplet",			"Unvollständig"			},
					WARNING		= { "Warning",				"Warning",				"Avertissement",		"Warnung"				},
					ERROR		= { "Error",				"Error",				"Erreur",				"Fehler"				},
					REQUESTED	= { "Requested",			"Requested",			"Demandée",				"Nachgefragt"			},
					GRANTED		= { "Granted",				"Granted",				"Accordée",				"Zugesagt"				},
					SECTION_TAG	= { "section",				"avsnitt",				"zone",					"Abschnitt"				},
					SEGMENT_TAG = { "Segment",				"Segment",				"Segment",				"Segment"				},
					SECTION		= { "SymbolFrame-R2.75",	"Symbolramme-R2.75",	"",						""						}
					SEGMENT		= { "SymbolFrame-R2.75",	"Symbolramme-R2.75",	"CadreSymbole-R2.75",	"Symbolrahmen-R2.75"	}
				}
				--Priority: Show HISTORIC then UNFINISHED then ERROR then WARNING then OTHERs then NO_FRAME
				-- By convention, historic layers have names starting with a double 'at' character '@@':
				if (layer:sub(1,2) == '@@') then
					return _frames.HISTORIC[_language]
				end
			
				--Check code and name for keywords:
				--(inhibit evaluation of 'code' and 'name', since RC will not allow us to nest Lua calls too deep, 5 levels max)
				local thisCode = getPropertyValue("code")
				local thisName = getPropertyValue("name")
				local t
				t = _frames["UNFINISHED"][_language]
				if tostring(thisCode):upper():match(t:upper()) or tostring(thisName):upper():match(t:upper()) then 
					return t
				end
			
				t = _frames["WARNING"][_language]
				if tostring(thisCode):upper():match(t:upper()) or tostring(thisName):upper():match(t:upper()) then 
					return t
				end
			
				t = _frames["ERROR"][_language]
				if tostring(thisCode):upper():match(t:upper()) or tostring(thisName):upper():match(t:upper()) then 
					return t
				end

				--Then scan the modelchecks for unfished items, warnings or errors - but suppress the symbolframe if a derogation
				--has been requested or has been granted:
				modelChecks = LuaExpressions:filter(function(x) return x.IsModelCheck end)
				if (modelChecks:filter(function(x) return x.Symbol == "_unfinished" end).Count &gt; 0) then
					return _frames.UNFINISHED[_language]
				elseif Derogation == "REQUESTED" then return _frames.REQUESTED[_language]
				elseif Derogation == "GRANTED" then return _frames.GRANTED[_language]
				elseif (modelChecks:filter(function(x) return x.Symbol == "_error" end).Count &gt; 0) then
					return _frames.ERROR[_language] --Deviating, no derogation requested or granted
				elseif (modelChecks:filter(function(x) return x.Symbol == "_warning" end).Count &gt; 0) then
					return _frames.WARNING[_language] --Deviating, no derogation requested or granted
				else
					--do nothing, fall through to next check
				end
			
				--Then scan the various relations and their cardinalities to check for unsatisfied minimum requirements:
				ss = Relations.SourceSpace
				rel = Relations.ObjectRelations
				nRel = getCollectionLength(rel)
				for i = 0,nRel-1 do
					r = rel[i]
					--[[
						Example - object is a high voltage switch (Norw: Bryter)
						r = this.Relations.Objectrelations
						r.RelationPromptText			rel_HvSwitch_Has_HvSwitchActuator
						r.Relation.RelatesTo.Min		0
						r.Relations						Collection is empty (no forward relation exists)
						r.ReverseRelationPromptText		rel_HvSwitchActuator_Actuates_HvSwitch
						r.Relation.ReverseRelatesTo.Min	1
						r.ReverseRelations				Name-of-related-object(1 reverse relation found)
					--]]
					--[[
						Note: We might have relation prompt texts such as "Is xyzzy for xyzzy_charger/multi_xyxxz/buzzer",
						or just "Is xyzzy for multi_xyxxz", or just "Is xyzzy for buzzer". Don't accept partial word match.
						I.e., our search pattern must be followed by either slash '/' or end-of-line '$'.
						Also, we must start by substitution of all '-' with '%-', since '-' is a special character for match().
					--]]
					ss1 = ss:gsub("%-","%%-").."/" 
					ss2 = ss:gsub("%-","%%-").."$"
					t1 = (r.ReverseRelationPromptText:match(ss1) == ss)
					t2 = (r.ReverseRelationPromptText:match(ss2) == ss)
					--if true then return "Someone points to me = ".. ((t1 or t2) and "Yes" or "No") end
					if t1 or t2 then
						nForward = getCollectionLength(r.Relations)
						minForward = r.Relation.RelatesTo.Min
						--if true then return nRel,i,"---",nForward,minForward,r.RelationPromptText,"---",nReverse,minReverse,r.ReverseRelationPromptText end
						if nForward &lt; minForward then return _frames.UNFINISHED[_language] end
					end
			
					t3 = (r.RelationPromptText:match(ss1) == ss)
					t4 = (r.RelationPromptText:match(ss2) == ss)
					--if true then return "I point to someone = ".. ((t3 or t4) and "Yes" or "No") end
					if t3 or t4 then
						nReverse = getCollectionLength(r.ReverseRelations)
						minReverse = r.Relation.ReverseRelatesTo.Min
						--if true then return nRel,i,"---",nForward,minForward,r.RelationPromptText,"---",nReverse,minReverse,r.ReverseRelationPromptText end
						if nReverse &lt; minReverse then return _frames.UNFINISHED[_language] end
					end
				end
			
				--Now, look for derogations or else look for unsatisfied modelchecks:
				modelChecks = LuaExpressions:filter(function(x) return x.IsModelCheck end)
				if Derogation == "REQUESTED" then return _frames.REQUESTED[_language]
				elseif Derogation == "GRANTED" then return _frames.GRANTED[_language]
				elseif (modelChecks:filter(function(x) return x.Symbol == "_error" end).Count &gt; 0) then
					return _frames.ERROR[_language] --Deviating, no derogation requested or granted
				elseif (modelChecks:filter(function(x) return x.Symbol == "_warning" end).Count &gt; 0) then
					return _frames.WARNING[_language] --Deviating, no derogation requested or granted
				elseif (modelChecks:filter(function(x) return x.Symbol == "_unfinished" end).Count &gt; 0) then
					return _frames.UNFINISHED[_language]
				else
					--do nothing, fall through to next check
				end
			
				--If no problems remain, go on to show 'normal behaviour' frame for objects that feature a frame:
				--Deal with axle counter special section objects (the layer name will depend on the DNA in use):
				if RcType:upper():match(_frames.SECTION_TAG[_language]:upper()) then 
					return _frames.SECTION[_language]
				end
			
				--Deal with characteristic point special section objects (the layer name will depend on the DNA in use):
				if RcType:upper():match(_frames.SEGMENT_TAG[_language]:upper()) then 
					return _frames.SEGMENT[_language]
				end
			
				--Nothing recognised:
				return "" --no frame
			end
		</Formula>
	</LuaFunction>


	
<!--========================================================================================================
	'NOBN_com_xxx': NOBN Lua functions common to two or more railway disciplines.
=========================================================================================================-->
		<LuaFunction Name="NOBN_com_assessDerogation()" ReturnType="Enumeration"
		Description="Checks object model check attributes for warnings and errors, sets the derogation state accordingly to [ Normed | Deviating | Requested | Granted]." >
		<Constructor>Enumeration NOBN_com_assessDerogation()</Constructor>
		<Formula>
			function NOBN_com_assessDerogation()
				--The Derogation state variable influences the SymbolFrame function.
				--Warnings do not affect the derogation state, only errors do:
				errors = LuaExpressions:filter(function(x) return x.IsModelCheck and x.Symbol == "_error" end)
				d = getPropertyValue("Derogation") --Read property, do not refresh the entire object
				if errors.Count == 0 then
					if d == "DEVIATING" then
						return "NORMED" --Problem has disappeared
					else
						return d --No change if already manually set
					end
				else
					if d == "REQUESTED" or d == "GRANTED" then
						return d --No change if already manually set
					else
						return "DEVIATING" --Change state to warn user that a fix or a derogation is needed
					end
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_chkDistanceToClosestNeighbour()" ReturnType="String"
		Description="Checks distance to the closest neighbouring object of the specified object type in the specified search direction [ up | down ]. Error if below the specified error threshold, warning if below the specified warning threshold." >
		<Constructor>String NOBN_com_chkDistanceToClosestNeighbour(String objectType, Double errorThreshold, Double warningThreshold, Dir searchDir)</Constructor>
		<Formula>
			function NOBN_com_chkDistanceToClosestNeighbour(objectType,errorThreshold,warningThreshold,searchDir)
				if searchDir ~= "up" and searchDir ~= "down" then
					return "ERROR - Bad search direction '"..searchDir.."' - must be either 'up' or 'down'.",_error
				end
				if type(errorThreshold) ~= "number" or type(warningThreshold) ~= "number" or errorThreshold &lt; 0 or warningThreshold &lt;= errorThreshold then
					return "ERROR - Thresholds must be numbers such that 0 &lt; errorThreshold &lt; warningThreshold.",_error
				end
				if type(objectType) ~= "string" then
					return "ERROR - Object type must be a string containing the object type's 'RcType' property.",_error
				end
				if Alignment == nil then
					return "UNFINISHED - Missing own alignment.",_error
				end
				closest = (searchDir == "down") and getDownObject(objectType) or getUpObject(objectType)
				if closest == nil then
					return "OK - No "..objectType:sub(10).." within reach in the '"..searchDir.."' direction.",_ok
				end
				dist = distance(closest)
				t = string.format("%.3f", dist)
				if dist &lt; errorThreshold then 
					return string.format("%.03f: ERROR - %s '%s' too close in '%s' direction, outside tolerance %0.3f m.", dist,objectType:sub(10),RC__identify(closest),searchDir,errorThreshold),_error
				elseif dist &lt; warningThreshold then 
					return string.format("%.03f: WARNING - %s '%s' close in '%s' direction, but within tolerance %0.3f m.",dist,objectType:sub(10),RC__identify(closest),searchDir,errorThreshold),_warning
				else
					return string.format("%.03f: OK - %s '%s' is nearest in '%s' direction, farther away than tolerance %0.3f m.", dist,objectType:sub(10),RC__identify(closest),searchDir,errorThreshold),_ok
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_triggerNeighbourObjectModelchecks()" ReturnType="String"
		Description="Triggers modelchecking in all neighbour objects of the specified object type." >
		<Constructor>NOBN_com_triggerNeighbourObjectModelchecks(String objectType)</Constructor>
		<Formula>
			function NOBN_com_triggerNeighbourObjectModelchecks(objectType)
				if type(objectType) ~= "string" then
					return 0,{}, _info("ERROR - Bad object type '"..objectType.."'.")
				end
				if Alignment == nil then
					--Cannot do graph search without alignments:
					return 0,{}, _info("UNFINISHED - Missing own alignment.")
				end
				prev = getDownObjectsWithPaths(objectType)
				succ = getUpObjectsWithPaths(objectType)
				all = getUnionOfCollections({prev,succ}) --all is now a collection of tuples {Object,Path}
				n = getCollectionLength(all)
				t = {}
				for i = 0,n-1 do
					table.insert(t,all[i].Object)
				end
				return n,t, _info(n.." items of "..objectType.." have been modelchecked.")
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_assistAssignEarthingAlignment()" ReturnType="AlignmentRef"
		Description="Suggests an earthing alignment reference for an object, based on its RcType, its Variant and its surroundings. The function assumes that rails of RcType '&quot;..rctype_InnerRailAndInsulation..&quot;' are present and have been divided already into insulated and non-insulated sections." >
        <Constructor>AlignmentRef NOBN_com_assistAssignEarthingAlignment([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_com_assistAssignEarthingAlignment(obj)
				--TODO: Consider replacing "Red/Green" filter with a downwards search for track insulation with railML property 'left', 'right', 'both', 'none' (in associated track).
				if obj == nil then obj = this end
			
				--Gauge tolerance when looking for rails belonging to the same track:
				gaugeTolerance = 0.030 --[m]
				--If not too far away, we prefer a dedicated earth rail over double insulated track, where you should consider not earthing to both rails:
				railDistanceTolerance = 6.000  --[m]
			
				if EarthingMethod == "None" then 
					return
			
				elseif EarthingMethod == "Unknown" then 
					return _info("UNFINISHED - Earthing method is Unknown, cannot deduce EarthingAlignment.")
					
				elseif EarthingMethod == "Rail" then
					r = getClosestAlignments(rctype_InnerRailAndInsulation,obj):filter(function (x) return x:getPropertyValue("Color"):upper() == "RED" end)
					if getAlignmentInfo(r[0].id,obj).NormalProjectionExists then
						--Find distance sideways to closest insulated rail:
						d = getAlignmentInfo(r[0].id,obj).DistanceToAlignment
					else
						--No normal projection exists onto insulated rail, so look for  distance to closest start/end of closest insulated rail:
						d = math.min(RC__getDistance2D(r[0].RcAlignment.StartPoint,obj),RC__getDistance2D(r[0].RcAlignment.EndPoint,obj))
					end
					if math.abs(d) &lt;= railDistanceTolerance then
						--If distance to insulated rail is reasonably short, then use it now...
						return r[0]
					else 
						--...otherwise, check if the two closest *un*insulated rails belong to the same track, asuuming both are (through use of impedances) carrying return current:
						--Btw, this proceudre fails if the object is between two tracks where insulated rail distances are just above the tolerance, so that the two closest 
						--return rails belong to two *different* railway tracks.
						r = getClosestAlignments(rctype_InnerRailAndInsulation):filter(function (x) return getAlignmentInfo(x.id).NormalProjectionExists and x.color:upper() == "GREEN" end)
						n = getCollectionLength(r)
						d0 = getAlignmentInfo(r[0].id,obj).DistanceToAlignment
						d1 = getAlignmentInfo(r[1].id,obj).DistanceToAlignment
						if math.abs(math.abs(d0-d1) - r[0].AlignmentSystem.AlignmentGauge) &lt; gaugeTolerance then
							--Pick closest un-insulated rail, although it is 'bad taste' if we thereby end up
							--with objects earthed to both rails within one double-insulated track circuit:
							return r[0]
						else
							return _info("Search for nearby rails suitable for protective earthing failed (i.e., rails of type '"..rctype_InnerRailAndInsulation.."', carrying return current).")
						end
					end
					r = getClosestAlignments(rctype_InnerRailAndInsulation,obj):filter(function (x) return x:getPropertyValue("Color"):upper() == "RED" end)
					return r[0]
			
				elseif EarthingMethod == "Wire" then 
					r = getClosestAlignments(rctype_EarthingConductor,obj)
					return r[0]
					
				elseif EarthingMethod == "Object" then 
					--Just return - and let similar Lua code for the 'EarthingObject' reference property do the job:
					return
				end
			end
        </Formula>
    </LuaFunction>

	<LuaFunction Name="NOBN_com_assistAssignEarthingObject()" ReturnType="ObjectRef"
		Description="Suggests an earthing object reference for an object, based on its RcType, its Variant and its surroundings. The function assumes that there is an object nearby that can offer protective earth." >
        <Constructor>AlignmentRef NOBN_com_assistAssignEarthingObject([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_com_assistAssignEarthingObject(obj)
				if obj == nil then obj = this end
				local earthingConnectionMaxLength = 10 --[m]
			
				if obj.EarthingMethod == "None" then 
					return _void
				
				elseif obj.EarthingMethod == "Unknown" then 
					return _void, _info("UNFINISHED - Earthing method is Unknown, cannot deduce EarthingObject.")
				
				elseif obj.EarthingMethod == "Rail" then
					return _void
				
				elseif obj.EarthingMethod == "Wire" then 
					return _void
				
				elseif obj.EarthingMethod == "Object" then 
					local npo = getNearbyPointObjects2D(earthingConnectionMaxLength,obj):filter
						(function (x)
							local em = x:getPropertyValue("EarthingMethod")
							local ea = x:getPropertyValue("EarthingAlignment")
							local eo = x:getPropertyValue("EarthingAlignment")
							return 
								((em == 'Rail' or em == 'Wire') and (ea and ea ~= obj))
								or
								((em == 'Object') and (eo and eo ~= obj))
						end)
					if getCollectionLength(npo) &gt; 0 then
						return npo[0]
					else 
						return _void,_error, _info("UNFINISHED - Earthing method is Object, but no suitable earth providing objects found.")
					end
					
				else
					-- Should not happen
					return nil, _info("ERROR - Bad Earthing Method.")
				end
			end
        </Formula>
    </LuaFunction>
		
	<LuaFunction Name="NOBN_com_assistAssignEarthingLabelText()" ReturnType="String"
		Description="Suggests an earthing alignment label text for an object, based on its RcType, its Variant and its surroundings. The function assumes that the object already has a defined EarthingMethod and EarthingAlignment/EarthingObject." >
        <Constructor>String NOBN_com_assistAssignEarthingLabelText([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_com_assistAssignEarthingLabelText(obj)
				if obj == nil then obj = this end
				if obj.EarthingMethod == "None" then 
					return ""
				elseif obj.EarthingMethod == "Object" then
					return RC__identify(obj.EarthingObject).." / "..RC__identify(obj)
				elseif obj.EarthingMethod == "Wire" then 
					return RC__identify(obj.EarthingAlignment).." / "..RC__identify(obj)
				elseif obj.EarthingMethod == "Rail" then 
					return RC__identify(obj.EarthingAlignment).." / "..RC__identify(obj)
				elseif obj.EarthingMethod == "Unknown" then 
					return "(?)".." / "..RC__identify(obj)
				else
					return _error, "ERROR - Bad Earthing Method ["..obj.EarthingMethod.."]."
				end
			end
        </Formula>
    </LuaFunction>

	<LuaFunction Name="NOBN_com_assignEarthingLabelColor" ReturnType="String"
		Description="Assigns the color for the permanent marking tag attached to earthing connector, deduced from the object's discipline." >
        <Constructor>String NOBN_com_assignEarthingLabelColor([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_com_assignEarthingLabelColor(obj)
				obj = obj or this
				if obj.Discipline == "Felles" then return 7 --"Hvit"
				elseif obj.Discipline == "Underbygning" then return 7 --"Hvit"
				elseif obj.Discipline == "Overbygning" then return 7 --"Hvit"
				elseif obj.Discipline == "Kontaktledning" then return 1 --"Rød"
				elseif obj.Discipline == "Signal" then return 3 --"Grønn"
				elseif obj.Discipline == "Tele" then return 2 --"Gul"
				elseif obj.Discipline == "Lavspent" then return 5 --"Blå"
				elseif obj.Discipline == "Skilt" then return 7 --"Hvit"
				else 
					return _error, "ERROR - Uncrecognized discipline ["..obj.Discipline.."]."
				end
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="NOBN_com_assistAssignEarthingPosBias()" ReturnType="Double"
		Description="Suggests an earthing alignment pos bias for an object, based on its earthing method and its surroundings. A non-zero bias moves the 'earthing landing point' along the earthing alignment." >
        <Constructor>Double NOBN_com_assistAssignEarthingPosBias([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_com_assistAssignEarthingPosBias(obj)
				if obj == nil then obj = this end
				local offset = 1
				if obj.EarthingMethod == "Rail" then
					if getAlignmentInfo(obj.EarthingAlignment.id).NormalProjectionExists then
						return 0
					else 
						--Move earth connection a little past insulation along insulated rail's tangent direction (at start or end of rail): 
						ps = obj.EarthingAlignment.RcAlignment.StartPoint
						pe = obj.EarthingAlignment.RcAlignment.EndPoint
						ds = RC__getDistance2D(ps,obj)
						de = RC__getDistance2D(pe,obj)
						if ds &lt; de then
							u = obj.EarthingAlignment.RcAlignment.StartTangent
							return ((ps.X-geoCoord.X)*u.X + (ps.Y-geoCoord.Y)*u.Y) > 0 and offset or -offset 
						else
							u = obj.EarthingAlignment.RcAlignment.EndTangent
							return ((ps.X-geoCoord.X)*u.X + (ps.Y-geoCoord.Y)*u.Y) > 0 and offset or -offset 
						end
					end
				end
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
	Track - general position issues, relative to track alignments, used by all objects.
	See also the lua source files for track objects and track connections.
=========================================================================================================-->
	<LuaFunction Name="NOBN_trk_toKm()" ReturnType="String"
		Description="Converts input x [m] into mileage [km] with precision p (0..6), default precision is 3. E.g., 462371.637 => 462.372." >
		<Constructor>Double NOBN_trk_toKm(Double x [, Int p])</Constructor>
		<Formula>
			function NOBN_trk_toKm(x,p) 
				if p == nil then 
					if x == nil then
						return 0.0,_warning
					else
						p = 3
					end
				end
				p = math.floor(math.abs(p))
				if p &lt; 0 or p &gt; 6 then
					return "Precision ["..p.."] must be from 0 to 6, cannot format value ["..x.."]",_warning
				elseif p == 0 then return string.format("%.0f",math.floor((x+0.5*1e3)*1e-3)/1e0)
				elseif p == 1 then return string.format("%.1f",math.floor((x+0.5*1e2)*1e-2)/1e1)
				elseif p == 2 then return string.format("%.2f",math.floor((x+0.5*1e1)*1e-1)/1e2) 
				elseif p == 3 then return string.format("%.3f",math.floor((x+0.5*1e0)*1e0)/1e3)
				elseif p == 4 then return string.format("%.4f",math.floor((x+0.5*1e-1)*1e1)/1e4) 
				elseif p == 5 then return string.format("%.5f",math.floor((x+0.5*1e-2)*1e2)/1e5) 
				elseif p == 6 then return string.format("%.6f",math.floor((x+0.5*1e-3)*1e3)/1e6) 
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getNearestEntireKm()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when also half km is to be shown, e.g., 461.749 => 461 (half km is 5) and 461.750 => 462 (half km is 0)." >
		<Constructor>Int NOBN_com_getNearestEntireKm([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function NOBN_com_getNearestEntireKm(obj)
				obj = obj or this
				return math.floor(math.floor((obj:getPropertyValue("ReferenceMileage")/500)+.5)/2)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getNearestEntireKm2()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when the half km is not to be shown, e.g., 461.499 => 461 and 461.500 => 462." >
		<Constructor>Int NOBN_com_getNearestEntireKm2([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function NOBN_com_getNearestEntireKm2(obj)
				obj = obj or this
				return math.floor(math.floor(obj:getPropertyValue("ReferenceMileage")/1000 + 0.5))
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getNearestHalfKm()" ReturnType="String"
		Description="Returns object's reference mileage's half km (0 or 5), e.g., 461.750 => 0 (whole km is 461) and 462.372 => 5 (whole km is 462)." >
		<Constructor>Int NOBN_com_getNearestHalfKm([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function NOBN_com_getNearestHalfKm(obj)
				obj = obj or this
				return (math.floor((obj.ReferenceMileage/500)+0.5)%2)*5
			end
		</Formula>
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_com_getNearestHectometricSnap()" ReturnType="String"
		Description="Returns object's reference mileage's nearest whole hectometer." >
		<Constructor>Int NOBN_com_getNearestHectometricSnap([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function NOBN_com_getNearestHectometricSnap(obj)
				obj = obj or this
				return 100 * ((50 + obj:getPropertyValue("ReferenceMileage")) // 100)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getNearestKilometricSnap()" ReturnType="String"
		Description="Returns object's reference mileage's nearest whole kilometer." >
		<Constructor>Int NOBN_com_getNearestKilometricSnap([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function NOBN_com_getNearestKilometricSnap(obj)
				obj = obj or this
				return 1000 * ((500 + obj:getPropertyValue("ReferenceMileage")) // 1000)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getLabelItem1()" ReturnType="String"
		Description="Returns the ReferenceMileage, formated as Km.&lt;value&gt;, for the label's own insertion point." >
		<Constructor>String NOBN_com_getLabelItem1()</Constructor>
		<Formula>
			function NOBN_com_getLabelItem1()
				return "Km."..NOBN_trk_toKm(referenceMileage,3)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getLabelItem2()" ReturnType="String"
		Description="Returns a list consisting of the Code for each item related to the label (labels can relate to anything)." >
		<Constructor>String NOBN_com_getLabelItem2()</Constructor>
		<Formula>
			function NOBN_com_getLabelItem2()
				local r,n,s,i
				s = rel_Label_AppliesTo_Anything
				r,n = getRelatedObjects(s)
				if n == 0 then 
					return "UNFINISHED - Relate with '"..s.."'."
				else
					t = "("..r[0].code
					for i = 1, n-1 do
						t = t..", "..r[i].code
					end
					return t..")"
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getLabelItem3()" ReturnType="String"
		Description="Returns the reference alignment Code for the label itself (not for a related item)." >
		<Constructor>String NOBN_com_getLabelItem3()</Constructor>
		<Formula>
			function NOBN_com_getLabelItem3()
				return "(Ref. "..referenceAlignment.code..")"
			end
		</Formula>
	</LuaFunction>



 	<LuaFunction Name="NOBN_trk_getLiftFromCant()" ReturnType="Double"
		Description="Returns a track-bound object's Z-coordinate offset above the gradient curve [m], consistent with own alignment's local cant. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument." >
		<Constructor>Double NOBN_trk_getLiftFromCant([_position])</Constructor>
		<Formula>
			function NOBN_trk_getLiftFromCant(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				if where == nil then
					-- can be called from point objects:
					ai = getAlignmentInfo()
				else
					-- can be called from anywhere, including an alignment, as a sampled formula:
					ai = getAlignmentInfo(where)
				end
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
					lwc = Alignment.AlignmentSystem.QuickMode3DLiftWithCant
					dta = DistanceToAlignment
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
					lwc = AlignmentSystem.QuickMode3DLiftWithCant
					dta = 0.0 --DistanceToAlignment
				end
				if not lwc then 
					return 0.0, _info("Alignment system does not lift with cant.")
				end
				c = ai.Cant
				if c == nil or RC__isNan(c) then
					return 0.0, _info("UNFINISHED - No cant data in alignment, assuming zero cant.")
				elseif c == 0 then
					return 0.0
				else
					-- Cant is measured in millimeter superelevation
					-- Ask alignment system whether cant leads to lift or not:
					h = c/1000.0 --[m]
					if h &gt; cg then 
						h = cg - 0.001 -- Almost 90 degrees roll...
						msg = "Cant truncated to max, "..RC__round(1000*h).." mm."
					else
						msg = RC__round(1000*h).." mm cant."
					end
					railSeparationXY = math.sqrt(cg^2 - h^2)
					if h == 0.0 then
						return 0.0, _info(msg)
					else
						cr = ai.CantRotation
						if cr == "CCW" then
							-- Right rail lifted above left rail
							return h/2 + h/2 * dta / (railSeparationXY / 2)
						elseif cr == "CW" then
							-- Left rail lifted above right rail
							return h/2 - h/2 * dta / (railSeparationXY / 2)
						else
							return 0.0,_error, _info("Bad cant rotation data ["..CantRotation.."], assuming zero lift.")
						end
					end
				end
			end
		</Formula>		
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_trk_getDistanceToAlignmentFromCantAndTrackPlaneDistance()" ReturnType="Double"
		Description="Returns a track-bound object's 2D distance to the alignment axis (IFC:gradient curve) as a function of its track plane distance to own model insertion axis. 'TrackPlaneDistance' is by default set to half of the rail separation (track gauge). If called from an alignment object, the reserved identifier '_position' holding a {Pos, Ref} must be provided as an input argument." >
		<Formula>
			function NOBN_trk_getDistanceToAlignmentFromCantAndTrackPlaneDistance(TrackPlaneDistance,where)
				local cg
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
				end
				if TrackPlaneDistance == nil then
					--No specific distance as input, use side of track and place on rail:
					TrackPlaneDistance = RightSided and cg/2.0 or -cg/2.0
				end
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				if where == nil then
					-- Assume function has been called from a point object:
					ai = getAlignmentInfo()
				else
					ai = getAlignmentInfo(where)
				end
				g = ai.Gradient
				h = ai.Cant/1000.0
				if RC__isNan(h) then 
					return TrackPlaneDistance, _info("No cant data in alignment, assuming zero cant.")
				else
					-- Scale track plane distance to alignment with effect of cant:
					return TrackPlaneDistance * math.sqrt(1 - (h/cg)^2)
				end
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_trk_getRollFromCant()" ReturnType="Double"
		Description="Returns a track-bound object's sideways roll [Decimal Degrees], consistent with own alignment's local cant and object direction up/down. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument." >
		<Constructor>Double NOBN_trk_getRollFromCant([_position])</Constructor>
		<Formula>
			function NOBN_trk_getRollFromCant(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				if where == nil then
					-- Assume function was called from a point object:
					ai = getAlignmentInfo()
				else
					-- can be called from anywhere, including an alignment, as a sampled formula:
					ai = getAlignmentInfo(where)
				end
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
				end
				c = ai.Cant
				if c == nil or RC__isNan(c) then
					return 0.0, _info("UNFINISHED - No cant data in alignment, assuming zero cant.")
				elseif c == 0 then
					return 0.0
				else
					-- Cant is measured in millimeter superelevation, with rotation clockwise or counterclockwise in the track's direction
					-- Assume that only one rail is lifted at a time.
					h = c/1000.0
					cr = tostring(ai.CantRotation)
					if  cr:upper() == "CW" then
						return math.asin(h/cg)*(180/math.pi)
					elseif cr:upper() == "CCW" then 
						return -math.asin(h/cg)*(180/math.pi)
					else
						return 90.0,_error, _info("Bad cant rotation data ["..CantRotation.."], assuming 90 degrees roll as a visual warning.")
					end
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_getRollFromCantInterpretedAsDecimalDegrees()" ReturnType="Double"
		Description="Returns a roll angle deduced from an alignment's cant, where Cant is interpreted as decimal degrees and CW/CCW." >
		<Constructor>Double NOBN_com_getRollFromCantInterpretedAsDecimalDegrees([_position])</Constructor>
		<Formula>
			function NOBN_com_getRollFromCantInterpretedAsDecimalDegrees(where)
				--If called to express e.g. a road, or OCS wire clamps or sweeping a contact wire, then '_position' is provided by RC, sampled along the alignment.
				if where == nil then
					ai = getAlignmentInfo()
				else
					ai = getAlignmentInfo(where)
				end
				angleInDecimalDegrees = ai.Cant --  NB! Cant is interpreted as decimal degrees CW/CCW.
				if (RC__isNan(angleInDecimalDegrees)) then
					return 0, _info("UNFINISHED - No cant (to be interpreted as an angle in decimal degrees) data in non-track alignment, assuming zero cant.")
				elseif angleInDecimalDegrees == 0 then
					return 0
				else
					-- Cant is measured in millimeter superelevation, with rotation clockwise or counterclockwise in the track's direction
					-- Assume that only one rail is lifted at a time.
					cr = tostring(ai.CantRotation)
					if  cr:upper() == "CW" then
						return angleInDecimalDegrees
					elseif cr:upper() == "CCW" then 
						return -angleInDecimalDegrees
					else
						return 90.0,_error, _info("Bad cant rotation data ["..CantRotation.."], assuming 90 degrees roll as a visual warning.")
					end
				end
			end
		</Formula>
	</LuaFunction>


	
	<!-- TODO Create functions for 3D Offset and Rotation so that they use _position and can be used in line 3D export too. -->
	<LuaFunction Name="NOBN_trk_getPitchFromGradient()" ReturnType="Double"
		Description="Returns a track-bound object's pitch [decimal degrees], consistent with own alignment's local gradient, and object orientation up/down/both/none. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument." >
		<Constructor>Double NOBN_trk_getPitchFromGradient([_position])</Constructor>
		<Formula>
			function NOBN_trk_getPitchFromGradient(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC, sampled along the alignment.
				if where == nil then
					g = getAlignmentInfo().gradient
				else
					g = getAlignmentInfo(where).gradient 
				end
				if RC__isNan(g) then
					return 0.0, _info("No gradient data in alignment, assuming zero gradient.")
				else
					return math.atan(g/1000)*(180/math.pi)
				end
			end
		</Formula>
	</LuaFunction>
	
	
	
    <LuaFunction Name="NOBN_trk_getYawFromDir()" ReturnType="Double"
		Description="Returns object's 3D rotation [DD] from its direction property 'dir' (up/down/none/both) and side of alignment, as seen in the direction of increasing mileage. If a non-zero rotation [DD] is provided, then the rotation takes precedence over the 'dir' property. Balises are a special case, assuming cable extends to the right from the 3D model, a slight leftside bias turns the balise around so the cable extends at the left side of the track. Objects which do not feature the 'dir' property will return 0." >
        <Constructor>Double NOBN_trk_getYawFromDir([Double rotation])</Constructor>
		<Formula>
			function NOBN_trk_getYawFromDir(rotation)
				d = getPropertyValue("dir") --Strip off _symbol and _info() if any, get just the plain string value
				if d == nil then return 0 end
				if RcType == rctype_Balise then 
					--Special case: Place balise slightly to the right of center track to keep the cable extending to the right
					--We assume that all balises have cable extending to the right when seen in the 3D object's 'up' direction
					--(the cable will then be best protected for left-handed normal driving on double track lines).
					if AngularOffset == nil then 
						return RightSided and 0.0 or 180.0
					else	
						return AngularOffset + (RightSided and 0.0 or 180.0)
					end
				end
				if rotation == nil and AngularOffset == nil then
					-- No argument given, and no standard property 'AngularOffset' exists for the current object
					if d == 'up' then
						return 0.0
					elseif d == 'down' then
						return 180.0
					elseif d == 'both' then
						return RightSided and -90.0 or 90.0
					elseif d == 'none' then
						return RightSided and 90.0 or -90.0
					else --d == unknown':
						return 45.0,_warning, _info("EnableDirectionSetting is 'unknown', cannot compute yaw, assuming 45 degrees as a visual warning.")
					end
				else
					--Modify 'dir' with extra rotation:
					if rotation == nil then
						--No arg given, use object's own AngularOffset:
						rotation = AngularOffset
					else 
						if math.abs(rotation) &lt; 4e-4 then 
							rotation = 0.0 --remove small inaccuracies
						end
					end
					if d == 'up' then
						return rotation, _info("'up' with "..rotation.." degrees extra rotation.")
					elseif d == 'down' then
						return 180.0+rotation, _info("'down' with "..rotation.." degrees extra rotation.")
					elseif d == 'both' then
						return (RightSided and -90.0 or 90.0) + rotation, _info("'both' with "..rotation.." degrees extra rotation.")
					elseif d == 'none' then
						return (RightSided and 90.0 or -90.0) + rotation, _info("'none' with "..rotation.." degrees extra rotation.")
					else --d == unknown':
						return 45.0,_warning, _info("The basic direction is 'unknown', cannot compute yaw, assuming 45 degrees as a visual warning .")
					end
				end
			end
		</Formula>
	</LuaFunction>

	
	
<!--========================================================================================================
	Track - Continuations, switches and crossings
=========================================================================================================-->
	<!-- INFO 2019-05-07 CLFEY: OCS Lua functions moved to file for TrackCOnnections / TrackObjects. -->

	
<!--========================================================================================================
	Signalling
=========================================================================================================-->
	<LuaFunction Name="NOBN_sig_getSignalSightingRequirement()" ReturnType="String"
		Description="Returns the sighting requirement according to TRV regulations for signals. Speed is extracted from the object's own alignment using 'getAlignmentInfo().Speed'. If no design speed is found in the object's own alignment, then 130 km/h will be assumed." >
		<Constructor>Double NOBN_sig_getSignalSightingRequirement()</Constructor>
		<Formula>
			function NOBN_sig_getSignalSightingRequirement()
				local DesignSpeed = getAlignmentInfo().Speed or 130 --130 km/h assumed if alignment has no design speed available
			
				if RcType == rctype_EtcsEoA then
					-- ERTMS marker board - Fixed 150 m requirement?
					if MarkerBoard == "-" then
						return 150, _info(DesignSpeed.." km/h: 150 m fixed sighting requirement for ERTMS boards.")
					elseif DwarfSignal == "Ja" and MarkerBoard == "-" then
						return 50, _info("50 m fixed sighting requirement during shunting movements (NB! There are rules for sight/stopping distance towards Ss43 as well).")
					end
				
				elseif RcType == rctype_Signal then
					if not (MainSignal:match("^Hs") or  DistantSignal:match("Ja")) and (DwarfSignal == "Ja" or HighShuntingSignal == "Ja") then
						return 50, _info("50 m fixed sighting requirement during shunting movements (NB! There are rules for sight/stopping distance towards Ss43 as well).")
				
					elseif (MainSignal:match("^Hs") or EndOfTrainRoute == "Ja") and (DistantSignal == "-") then
						-- Ref TRV Signal prosjektering, 2.1.2 "Hovedsignal"
						--NB! If through-signalling is in use, the sighting requirements are reduced to 80 km/h requirements - see TRV change ca 2019.
						if DesignSpeed &gt; 210 then
							return 250, _info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, and 250 m above 210 km/h.")
						else 
							v = math.max(135,math.min(210,DesignSpeed))
							return RC__round(v/3.6 * 4, 0), _info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, max. 250 m above 210 km/h.")
						end
			
					elseif DistantSignal == "Ja" then 
						-- Ref TRV Signal prosjektering, 2.1.3 "Forsignal"
						v = math.max(40,math.min(130,DesignSpeed))
						return RC__round(v/3.6 * 7, 0), _info(DesignSpeed.." km/h: Min. 78 m distant signal unbroken sighting, 7 seconds from 40 to 130 km/h, max 250 m above 130 km/h.")
			
					elseif HighShuntingSignal ~= "-" then
						return 50, _info("50 m fixed sighting requirement during shunting movements.")
				
					else
						return 0, _info(DesignSpeed.." km/h: Bad JBTSA_SIG Signal type [RcType="..RcType..", Variant="..(Variant and "(void)" or Variant.."."))
					end
			
				
				elseif RcType == "JBTSA_SIG PLO-signal" then
					-- Ref TRV Signal prosjektering, 2.1.2 "Hovedsignal"
					if DesignSpeed &gt; 210 then
						return 250, _info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, and 250 m above 210 km/h.")
					else 
						v = math.max(135,math.min(210,DesignSpeed))
						return RC__round(v/3.6 * 4, 0), _info(DesignSpeed.." km/h: Min. 150 m main signal unbroken sigthing, 4 seconds from 135 to 210 km/h, max. 250 m above 210 km/h.")
					end
			
				elseif RcType == "SA-SIG PLO-forsignal" then
					-- Ref TRV Signal prosjektering, 2.1.3 "Forsignal"
					v = math.max(40,math.min(130,DesignSpeed))
					return RC__round(v/3.6 * 7, 0), _info(DesignSpeed.." km/h: Min. 78 m distant signal unbroken sighting, 7 seconds from 40 to 130 km/h, max 250 m above 130 km/h.")
			
				elseif RcType == rctype_LevelCrossingSignalTowardsRoad then
					--Signal mot vei
					return 30, _info("30 m fixed sighting requirement for road traffic towards level crossing signal (To be verified!).")
			
				elseif RcType == rctype_BridgeAndFrostDoorSignal then 
					--Samme byggeteknikk som for 3-lys Hs (2 røde blink / 1 hvit blink)
					return 150, _info("150 m fixed sighting requirement for bridge / frost gate signal (To be verified!).")
			
				elseif RcType == rctype_TrackSignal then
					--Ingen spesielle krav, plasseres når lokfører eller ombordansvarlig ikke ser hovedsignal (ikke tillatt i nye anlegg)
					return 50, _info("50 m fixed sighting requirement for Togsporsignal (old type RepHs repeater signal) (To be verified!).")
			
				else
					return 0, _info(DesignSpeed.." km/h: Bad signal type [RcType="..RcType..", Variant="..(Variant or "(void)").."].")
				end
			end
		</Formula>
	</LuaFunction>


	
<!--========================================================================================================
	bnp - Boards 'n poles
=========================================================================================================-->
	<LuaFunction Name="NOBN_bnp_getBoardOffset3dZ()" ReturnType="String"
		Description="Returns the default pole 3D offset Z, i.e. the height of the pole." >
		<Constructor>Double NOBN_bnp_getBoardOffset3dZ()</Constructor>
		<Formula>
			function NOBN_bnp_getBoardOffset3dZ()
				-- To be mounted below other board on common pole:
				if Variant:find("Meterangivelse") then return 2.6 --May be placed under 68F
				elseif Variant:find("68F") then return 2.8 --Tilleggshastighet, to be placed under 68
			
				--To be mounted relatively low on NSI63 optical signal's mast:
				elseif Variant:find("62") then return 2.85 --Ugyldighetssignal på standard Bane NOR signalmast alternativ 2
				elseif Variant:find("72") then return 2.45 --FJS begynner/slutter
				elseif Variant:find("73") then return 2.45 --Rasvarsling
				elseif Variant:find("F-ATC") or Variant:find("D-ATC") then return 2.9
			
				--To be mounted on front/top of optical light signal's sunscreen:
				elseif Variant:find("60E") then return 5.80 --ATC Varsel. Remember to adjust Offset3d.Y as well.
			
				--Close to track, low placement, with pole:
				elseif Variant:find("Bevegelig kryss") then return 0.5 --Short vertical pole close to track
				elseif Variant:find("69") then return 1.5 --Temporary speed restriction, to be mounted with horizontal pole to track/sleeper
			
				--Close to track, low placement, no pole:
				elseif Variant:find("Baliseskilt") then return 0.0 --Mounted on platform element's side towards track, at A-balise
			
				--May be hanging from portal, othwerwise on own pole:
				elseif Variant:find("Spornummer") then return PortalMounted and -1 or 3.5
				-- TODO elseif Variant:find("E34") then return PortalMounted and -1 or 3.5 --ERTMS Stedsskilt
				elseif Variant:find("E35") then return PortalMounted and -1 or 3.5 --ERTMS Stoppskilt
			
				--To be read by train driver sitting in train, AND by walking people:
				elseif Variant:find("1000V") then return 2.5
				elseif Variant:find("kjedebrudd") then return 2.5
			
				--To be read by walking people:
				elseif Variant:find("Nødtelefon") then return 2.00
				elseif Variant:find("Stopp se og lytt") then return 2.00 --Skilt langs bilvei, for mennesker
				elseif Variant:find("Arbeidsområde") then return 2.02 --Tenkt montert på et NSI hovedsignal
			
				-- High relative Elevations, no pole:
				elseif Variant:find("75B") then return 0.0 --Old km board type, directly on tunnel wall (high RelativeElevation)
				elseif Variant:find("Rømningsavstand") then return 0.0 --Escape route distance / direction board, directly on tunnel wall
			
				else 
					return 3.5
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_bnp_getPoleRoutingDefaultValue()" ReturnType="String"
		Description="Returns the default pole setting for the board in question, from {'none','vertical','horizontal'}." >
		<Constructor>Enumeration {'None','Vertical','Horizontal'} NOBN_bnp_getPoleRoutingDefaultValue()</Constructor>
		<Formula>
			function NOBN_bnp_getPoleRoutingDefaultValue()
				if RcType == rctype_EtcsEoA then
					return "Vertical"
				
				elseif RcType:match("JBTSA_MSS") or RcType:match("JBTKO_SKT") or RcType:match("JBTEH_BKT") then
					--Those who do NOT use pole routing:
					if Variant:match("Baliseskilt")
					or Variant:match("60E")
					or Variant:match("62")
					or Variant:match("64")
					or Variant:match("65") --pantograph signs are usually mounted on OCS pole
					or Variant:match("67E")
					or Variant:match("68D%-2")
					or Variant:match("68D%-3")
					or Variant:match("68F")
					or Variant:match("70")
					or Variant:match("72A")
					or Variant:match("72B")
					or Variant:match("73")
					or Variant:match("Arbeidsområde")
					or Variant:match("138") --Trafikkskilt Andreaskors langs bilvei ved PLO, festes på lyssignal mot vei
					then 
						return "None"
					
					elseif Variant:find("69") then
						return "Horizontal" --Fixed with temporary bracket to closest rail/sleeper

					else 
						return "Vertical"
					end
				else
					return "None"
				end
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_bnp_getBoardSightingRequirement()" ReturnType="String"
		Description="Returns the sighting requirement according to TRV regulations for vegetation clearance towards boards. Speed is extracted from the object's own alignment using getAlignmentInfo().Speed." >
		<Constructor>Double NOBN_bnp_getBoardSightingRequirement()</Constructor>
		<Formula>
function NOBN_bnp_getBoardSightingRequirement()
	local DesignSpeed = getAlignmentInfo().Speed or 130 --130 km/h assumed if alignment has no design speed available

	if 	   Variant:find("Baliseskilt")
		or Variant:find("Arbeidsområde")
		or Variant:find("75C") -- 75C: Hev sporrenser
		or Variant:find("75D") -- 75D: Senk sporrenser
		or Variant:find("60E") --ATC Varsel - Monteres på Fs eller Hs+Fs
		or Variant:find("62") --Ugyldighetsskilt - står alltid sammen med Hs, Fs eller enkelt innkjørsignal
		or Variant:find("64E") --64E: Blå/Hvit Teknisk stolpe
		or Variant:find("67E") --Orienteringssignal dagtid, unngå å gi signal 83 "Tog kommer" mellom kl 22 og 06
		or Variant:find("68F") --Tilleggshastighet underskilt - står alltid sammen med signal 68AB
		or Variant:find("68G") --Krengetoghasighet underskilt - står alltid sammen med signal 68AB
		or Variant:find("101") --ID-skilt av alle typer
		or Variant:find("102") --PIL
		or Variant:find("138") --Trafikkskilt Andreaskors langs bilvei ved PLO, festes på lyssignal mot vei
	then
		--No sighting requirement:
		return 0, _info("No sighting requirement.")

	elseif
		(Variant:find("60") and not Variant:find("60E")) --60ABCD_FGH: ATC skilt
		or Variant:find("61") --61ABC: Avstandsskilt 1/2/3 (1000/800/250 meter)
		or Variant:find("63") --63AB: Fallviser/Stigningsviser
		or Variant:find("64A") --64A: Grense-innkoblingsstolpe
		or Variant:find("64B") --64B: Seksjoneringsstolpe
		or Variant:find("64C") --64C: Rasvarslingsstolpe
		or Variant:find("64D") --64D: Bremsestolpe
		or Variant:find("65") --65ABCDEFG: KL-skilt
		or Variant:find("66") --66: Togvei slutt
		or Variant:find("68A") --69A: Nedsatt hastighet
		or Variant:find("68B") --69B: Økt hastighet
		or Variant:find("68C") --69C: Avvikende hastighet
		or Variant:find("68D") --69D: Markeringsmerke
		or Variant:find("69") --69AB: Midlertidig hastighet
		or Variant:find("70") --70: Planovergangsskilt "V"
		or Variant:find("72") --72AB: FJS begynner/slutter
		or Variant:find("73") --73: Rasvarsling
		or Variant:find("74") --74: Toglengdeskilt
		or Variant:find("75A") --75AB: Kilometerskilt, gammel type
		or Variant:find("75B") --75AB: Kilometer, ny type
	then
		-- Ref TRV Underbygning vedlikehold, 2.1.1 "Sikt til signaler og skilt"
		v = math.max(40,math.min(130,DesignSpeed))
		d = RC__round(v/3.6 * 5, 0)
		return d, _info(d.."m required at "..DesignSpeed.." km/h (5 seconds unbroken sighting, min. 56m, max. 181m.")

	elseif		
		--Krav som til dvergsignaler pga kun aktuelle å observere under skifting (40 km/h / 50 meter)
		   Variant:find("51") --51ABCD: Sporvekselsignal, lysreflekterende. A=tilRettspor, B=fraAvvik, C=tilV, D=tilH
		or Variant:find("52") --52ABCD: Sporvekselsignal for kryssporveksel. A=fraVtilH, B=fraHtilV, C=fraVtilV, D=fraHtilH.
		or Variant:find("53") --53: Sporsperresignal, "sporet sperret"
		or Variant:find("54") --54: Sporsperresignal, "sporet fritt"
		or Variant:find("64E") --64E: Dvergsignalstolpe
	then
		return 50, _info("50 m fixed sighting requirement during shunting movements.")

	else
		return 0, _info(DesignSpeed.." km/h: Bad board type [RcType="..RcType..", Variant="..(Variant and "(void)" or Variant.."."))
	end
end
		</Formula>
	</LuaFunction>



<!--========================================================================================================
	ocs - Overhead catenary System Lua formulas (including return current and earthing)
=========================================================================================================-->
	<!-- INFO 2019-05-07 CLFEY: OCS Lua functions moved to file for OcsObjects. -->


<!--========================================================================================================
	sub - Substructure / civil works functions accessible globally
=========================================================================================================-->
	<LuaFunction Name="NOBN_sub_getFoundationCode()" ReturnType="String" 
		Description="Returns the code for a foundation / bolt group / deduced from its associated object (based on RcType and close proximity)." >
		<Constructor>String NOBN_sub_getFoundationCode([ObjRef obj])</Constructor>
		<Formula>
			function NOBN_sub_getFoundationCode(obj)
				local tol = 0.50 --[m] Look for a matching object close to 'obj'
				local function fn(obj,objectTypes,errMsg)
						--Check for matching objects in prioritized order.
					local ot,n,i,o
					ot = getCollectionFromTable(objectTypes)
					n = ot.count
					for i=0,n-1 do
						o = getNearbyPointObjects2D(tol,ot[i],obj)
						if getCollectionLength(o) &gt; 0 then return o[0].code end
					end
					return errMsg 
				end
			
				if obj == nil then obj = this end
				if RcType:match("JBTEH_FUN KL%-fundament") then 
					return fn(obj,{	rctype_OcsPole,
									rctype_OcsDropArmUnderPortal,
									rctype_OcsDropArmForBridgeOrTunnel,
									rctype_GuywireFootplate,
									rctype_SpannerFootplate,
									rctype_TunnelWallFixing
								},
								"UNFINISHED - no visible OCS pole or guywire / spanner fastener found at foundation.")
				elseif RcType:match(rctype_SignalFoundation) then 
					return fn(obj,{rctype_Signal},"UNFINISHED - no visible signal found at foundation.")
				elseif RcType:match(rctype_CabinetFoundation) then 
					return fn(obj,{rctype_SignallingCabinet},"UNFINISHED - no visible signal cabinet found at foundation.")
				elseif RcType:match(rctype_TelecomFoundation) then 
					return fn(obj,{"TODO: Define telecom objects here :ODOT"},"UNFINISHED - no visible matching telecom object found at foundation.")
				end
			end
		</Formula>
	</LuaFunction> 
		


<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>

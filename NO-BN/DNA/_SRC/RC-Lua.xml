<!--========================================================================================================

    RC-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml" />.

	(c) Railcomplete AS, Norway, 2015-2021. All rights reserved.
	
=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
    RC general and railway-independent Lua
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
	<!-- 2020-04-26 CLFEY - Deprecated, removed all use of function RC__EOSILON() (a constant used -->
	<!-- in model checking) - each check must set its onwn absolute error tolerances: -->
	<!-- <LuaFunction Name="RC__EPSILON()" ReturnType="Double" -->
		<!-- Description="Constant: Returns epsilon, a tolerance scaling number, to be used in model checks." > -->
		<!-- <Constructor>Double RC__EPSILON()</Constructor> -->
		<!-- <Formula> -->
			<!-- function RC__EPSILON() -->
				<!-- return 1.000 -->
			<!-- end -->
		<!-- </Formula> -->
	<!-- </LuaFunction> -->


	
	<LuaFunction Name="RC__getCollectionOfRelatedObjects()" ReturnType="Collection,Int"
		Description="Returns a collection of objects connected through the specified relation, and the number of related objects found. Source object and visibility are optional arguments." >
		<Constructor>Collection,Int RC__getCollectionOfRelatedObjects(String RelationName [,Reference Source [,Boolean Invisible]])</Constructor>
		<Formula>
			function RC__getCollectionOfRelatedObjects(RelationName,Source,Invisible)
				if Invisible then Invisible = true else Invisible = false end
				Source = Source or this
				--Is source a real object reference with an id?
				if Source.id == nil then
					return {},0,_warning,_info("*** RC__getCollectionOfRelatedObjects: Bad source object reference '"..tostring(Source).."'.")
				end
				if RelationName == nil then
					return {},0,_warning,_info("Missing relation name in function call.")
				elseif Source.Relations == nil then
					return {},0,_warning,_info("*** RC__getCollectionOfRelatedObjects: No such relation '"..RelationName.."' for object type '"..Source.RcType.."'.")
				end
				local r = Source.Relations[RelationName]
				if r == nil then
					return {},0
				elseif Invisible then
					return r,getCollectionLength(r)
				else
					r = r:filter(function (x) return x:isVisible() end)
					return r,getCollectionLength(r)
				end
			end
		</Formula>
	</LuaFunction>
	



	<LuaFunction Name="RC__getAngleFromDir()" ReturnType="Double"
		Description="Returns the angle in Decimal Degrees corresponding to the given direction [up | down | both | none | unknown]. 'Direction' and 'Rightsided' are optional arguments." >
		<Constructor>Double RC__getAngleFromDir([LaxDirection Direction [,Boolean RightSided]])</Constructor>
		<Formula>
			function RC__getAngleFromDir(d,rs)
				if d == nil then
					d = dir
					rs = RightSided
				elseif rs == nil then
					rs = false
				end
				if dir == 'up' then return 0
				elseif dir == 'down' then return 180
				elseif dir == 'both' then return rs and -90 or 90
				elseif dir == 'none' then return rs and 90 or -90 
				elseif dir == 'unknown' then return 45 
				else return 45,_info("Bad direction '"..d.."'.")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getMileageFromRelatedObject()" ReturnType="Double"
		Description="Returns the mileage for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getMileageFromRelatedObject(String RelationName [,Reference Source])</Constructor>
		<Formula>
			function RC__getMileageFromRelatedObject(RelationName,Source)
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Mileage"),_warning,_info("Missing relation name in function call.")
				end
				local r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Mileage"),_info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Mileage,
						_info("Mileage deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDistanceToAlignmentFromRelatedObject()" ReturnType="Double"
		Description="Returns the distance to alignment for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getDistanceToAlignmentFromRelatedObject(String RelationName [,Reference Source])</Constructor>
		<Formula>
			function RC__getDistanceToAlignmentFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("DistanceToAlignment"),_warning,_info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("DistanceToAlignment"),_info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("DistanceToAlignment deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).DistanceToAlignment,
						_info("DistanceToAlignment deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getRelativeElevationFromRelatedObject()" ReturnType="Double"
		Description="Returns the relative elevation above for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getRelativeElevationFromRelatedObject(String RelationName [,Reference Source])</Constructor>
		<Formula>
			function RC__getRelativeElevationFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("RelativeElevation"),_warning,_info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("RelativeElevation"),_info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then 
					return r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("RelativeElevation deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].geoCoord.Z - getAlignmentInfo(Source.Alignment.id, r[0].geocoord.X, r[0].geoCoord.Y).Elevation,
						_info("RelativeElevation deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getAngularOffsetFromRelatedObject()" ReturnType="Double"
		Description="Returns the angular offset for the projection of the related object onto the calling object's own alignment. Source object is an optional argument." >
		<Constructor>Double RC__getAngularOffsetFromRelatedObject(String RelationName [,Reference Source])</Constructor>
		<Formula>
			function RC__getAngularOffsetFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("AngularOffset"),_warning,_info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("AngularOffset"),_info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("AngularOffset deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getDirFromRelatedObject()" ReturnType="Double"
		Description="Returns the direction (Dir) from related object. Source object is an optional argument." >
		<Constructor>Double RC__getDirFromRelatedObject(String RelationName [,Reference Source])</Constructor>
		<Formula>
			function RC__getDirFromRelatedObject(RelationName,Source)
				local r,n
				Source = Source or this
				if RelationName == nil then 
					return getPropertyValue("Dir"),_warning,_info("Missing relation name in function call.")
				end
				r,n = RC__getCollectionOfRelatedObjects(RelationName,Source)
				if n == 0 then 
					return getPropertyValue("Dir"),_info("Object has no visible relation of type '"..RelationName.."'.")
				elseif n == 1 then
					return r[0].Dir,_info("Direction (Dir) deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."'.")
				else
					return _warning,
						r[0].AngularOffset + (r[0].AlignmentTangent - Source.AlignmentTangent) * 180.0/math.pi,
						_info("Direction (Dir) deduced from object '"..RC__identify(r[0]).."' related by '"..RelationName.."' (Note: more relations exist).")
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__acsVector2wcsVector()" ReturnType="String"
		Description="Converts an Alignment Coordinate System (ACS) 2D vector into a World Coordinate System (WCS) 2D vector. Usage: wx,wy = RC__acsVector2wcsVector(lateralOffset,alongOffset) or wx,wy = RC__acsVector2wcsVector(lateralOffset,alongOffset,alongAxisWcsAngle)." >
		<Constructor>Double,Double RC__acsVector2wcsVector(lateralOffset,alongOffset [,alongAxisWcsAngle = this.AlignmentTangent])</Constructor>
		<Formula>
			function RC__acsVector2wcsVector(acsX,acsY)
				--ACS = "Alignment Coordinate System", a basic RailCOMPLETE concept: 
				--acsX = Lateral offset to the right, perpendicular to the object's alignment axis
				--acsY = ALong offset in the direction of increasing distAlong, along the object's alignment axis
				--WCS = World Coordinate System, the CAD system's underlying absolute Cartesian coordinate system (XY-plane).
				local angle
				if alongAxisWcsAngle then 
					angle = math.rad(alongAxisWcsAngle - 90) --Subtract 90 DD since RailCOMPLETE ACS is 90 degrees off from Ifc / ISO 10303 usual axis definitions.
				else 
					angle = math.rad(this.AlignmentTangent - 90)
				end
				return acsX*math.cos(angle) + acsY*math.sin(angle), - acsX*math.sin(angle) + acsY*math.cos(angle)
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__identify()" ReturnType="String"
		Description="Returns the object's name if non-empty, or its code if non-empty, otherwise returns its ID. Addresses the calling object if no object reference is given." >
		<Constructor>String RC__identify([Reference obj])</Constructor>
		<Formula>
			function RC__identify(obj)
				obj = obj or this
				local t = obj:getPropertyValue("name")
				if t and t ~= "" then return t end
				t = obj:getPropertyValue("code")
				if t and t ~= "" then return t
				else return tostring(obj:getPropertyValue("id"))
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isNan()" ReturnType="Bool"
		Description="Returns true if input value is NaN (not a number), otherwise returns false." >
		<Constructor>Bool RC__isNan(Double value)</Constructor>
		<Formula>function RC__isNan(x) return x ~= x end</Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getUrlExtension()" ReturnType="String"
		Description="Returns filename extension (file type). Default url is the current document." >
		<Constructor>String RC__getUrlExtension([String url])</Constructor>
		<Formula>
			function RC__getUrlExtension(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[%.]([^%.]-)$") -- Extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDriveAndFolderAndFilename()" ReturnType="String"
		Description="Returns drive letter, folder name and file name. Default url is the current document." >
		<Constructor>String RC__getUrlDriveAndFolderAndFilename([String url])</Constructor>
		<Formula>
			function RC__getUrlDriveAndFolderAndFilename(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[%.][^%.]-$") -- Drive letter, folder and filename without extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDriveAndFolder()" ReturnType="String"
		Description="Returns drive letter and folder name. Default url is the current document." >
		<Constructor>String RC__getUrlDriveAndFolder([String url])</Constructor>
		<Formula>
			function RC__getUrlDriveAndFolder(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[\\/][^\\/]-$") -- Drive letter and folder name
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlDrive()" ReturnType="String"
		Description="Returns drive letter. Default url is the current document." >
		<Constructor>String RC__getUrlDrive([String url])</Constructor>
		<Formula>
			function RC__getUrlDrive(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("(.-)[:][^:]-$") -- Drive letter(s)
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlFilename()" ReturnType="String"
		Description="Returns filename without extension. Default url is the current document." >
		<Constructor>String RC__getUrlFilename([String url])</Constructor>
		<Formula>
			function RC__getUrlFilename(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[\\/]?([^\\/]-)[%.][^%.]-$") -- Filename without extension
			end
		</Formula>
	</LuaFunction>

	<LuaFunction Name="RC__getUrlFilenameAndExtension()" ReturnType="String"
		Description="Returns filename with extension. Default url is the current document." >
		<Constructor>String RC__getUrlFilenameAndExtension([String url])</Constructor>
		<Formula>
			function RC__getUrlFilenameAndExtension(url)
				if url == nil then url = DocumentData.DocumentName end
				return url:match("[\\/]?([^\\/]-)$") -- Filename and extension
			end
		</Formula>
	</LuaFunction>



	<!-- Special sub() pattern control characters are introduced with a byte in the range from 128 to 191, followed by a second byte that gives the  -->
	<!-- actual character, in combination with the first character. -->
	<!-- ^ anchors to start of string. \nnn means "byte contents nnn in decimal". * means "zero or more occurrences". $ means "pattern is anchored to end of string". -->
	<!-- RC__sub("skjØrteMåLET",9) == "åLET" -->
	<!-- RC__sub("skjØrteMåLET",3) == "jØrteMåLET" -->
	<!-- RC__sub("skjØrteMåLET",12) == "T" -->
	<!-- RC__sub("skjØrteMåLET",13) == "" -->
	<!-- RC__sub("skjØrteMåLET",1,1) == "s" -->
	<!-- RC__sub("skjØrteMåLET",4,3) == "" -->
	<!-- RC__sub("skjØrteMåLET") == "skjØrteMåLET" -->
	<!-- RC__sub("") == "" -->
	<!-- RC__sub() == "" -->
	<LuaFunction Name="RC__sub()" ReturnType="String"
		Description="Returns a substring of the input string, starting with its i-th multibyte letter and ending with its j-th multibyte letter (the built-in Lua method sub() will treat a string just as an array of individual bytes). By default, i=1 and j=i." >
		<Constructor>String RC__sub(String s [,Int i [,Int j]])</Constructor>
		<Formula>
			function RC__sub(s,i,j)
				local p,r,c,t
				if s == nil then s = "" end
				if type(s) ~= "string" then s = tostring(s) end
				if i == nil then i = 1 end
				if j == nil then j = s:len() end
				p = 1
				r = 1
				while r &lt; i and p &lt;= s:len() do
					c = s:sub(p,p):byte()
					if c >= 128 then --Assume 2-byte code
						p = p+2
					else
						p = p+1
					end
					r = r+1
				end
				t = ""
				while r &lt;= j and p &lt;= s:len() do
					c = s:sub(p,p):byte()
					if c &gt;= 128 then --Assume 2-byte code
						if p &lt; s:len() then 
							t = t..s:sub(p,p+1) 
						end
						p = p+2
					else
						t = t..s:sub(p,p)
						p = p+1
					end
					r = r+1
				end
				return t
			end
        </Formula>
	</LuaFunction>

  

	<LuaFunction Name="RC__round()" ReturnType="String"
		Description="Rounds floating point input x to p [-6..6] decimal places. Default precision is 0 decimals." >
		<Constructor>Double RC__round(Double x [, Int p])</Constructor>
		<Formula>
			function RC__round(x,p) 
				if math.abs(x) == math.huge then return x end --plus/minus Inf
				if p == nil then p = 0 end
				p = math.floor(p)
				if p &lt; -6 or p &gt; 6 then
					return "Precision ["..p.."] must be from -6 to 6, cannot format value ["..x.."]",_warning
				elseif p == 6 then x = string.format("%.6f",math.floor((x+0.5*1e-6)*1e6)/1e6)
				elseif p == 5 then x = string.format("%.5f",math.floor((x+0.5*1e-5)*1e5)/1e5) 
				elseif p == 4 then x = string.format("%.4f",math.floor((x+0.5*1e-4)*1e4)/1e4) 
				elseif p == 3 then x = string.format("%.3f",math.floor((x+0.5*1e-3)*1e3)/1e3) 
				elseif p == 2 then x = string.format("%.2f",math.floor((x+0.5*1e-2)*1e2)/1e2) 
				elseif p == 1 then x = string.format("%.1f",math.floor((x+0.5*1e-1)*1e1)/1e1) 
				elseif p == 0 then x = string.format("%d",math.floor((x+0.5*1e0)*1e0)/1e0)
				elseif p == -1 then x = string.format("%d",math.floor((x+0.5*1e1)*1e-1)/1e-1) 
				elseif p == -2 then x = string.format("%d",math.floor((x+0.5*1e2)*1e-2)/1e-2)
				elseif p == -3 then x = string.format("%d",math.floor((x+0.5*1e3)*1e-3)/1e-3)
				elseif p == -4 then x = string.format("%d",math.floor((x+0.5*1e4)*1e-4)/1e-4)
				elseif p == -5 then x = string.format("%d",math.floor((x+0.5*1e5)*1e-5)/1e-5)
				elseif p == -6 then x = string.format("%d",math.floor((x+0.5*1e6)*1e-6)/1e-6)
				end
				return tonumber(x)
			end
        </Formula>
	</LuaFunction>

  
  
	<LuaFunction Name="RC__snap()" ReturnType="String"
		Description="Returns nearest multiple of step size. Default step size is 3. E.g., 4.51 => 6 and -7.49 => -6." >
		<Constructor>Double RC__snap(Double x [, Double stepSize])</Constructor>
		<Formula>
			function RC__snap(x,stepSize) 
				if stepSize == nil then 
					if x == nil then
						return 0,_warning
					else
						stepSize = 3
					end
				end
				stepSize = math.floor(math.abs(stepSize))
				if stepSize == 0 then
					return 0
				else
					return stepSize * math.floor((x / stepSize) + 0.5)
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__getNearest3DStep()" ReturnType="Double"
		Description="Returns the nearest step value larger then the given argument (default is 10) which results in a complete 3D sweep of an alignment to ensure that the last sampled point is at the end of the alignment." >
		<Constructor>Double RC__getNearest3DStep(step) </Constructor>
		<Formula>
			function RC__getNearest3DStep(step)
				if step == nil then step = 10 end
				local a = RcAlignment
				-- is the caller an alignment?
				if a == nil then return step end
				local L = a.HorizontalProfile.Length
				if step &lt;= 0 or step &gt;= L then 
					return (L - 1e-3)
				else
					N = math.floor(L/step)
					return L/N - 1e-4
					--Note: if N gets very large then there might be a noticeable "missing link" at the end of the alignment
				end 
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="RC__isMemberOf()" ReturnType="Boolean" 
		Description="Returns true if table/collection/dictionary t contains object o. 'o' may be part of a numbered Lua sequence {3,5,7,11} or a value in a key/value pair {x=3,y=5,z=7,u=11}." >
		<Constructor>Boolean RC__isMemberOf(table t, Object o) </Constructor>
		<Formula>
			function RC__isMemberOf(t,obj) 
				local i
				if getTableValue(t) == nil and type(t) == "table" then
					-- A genuine Lua table, convert it to RailCOMPLETE/C# collection object (deleting the keys from key/value pairs):
					t = getCollectionFromTable(t)
					--Collections respond correctly to the '.count' attribute:
					for i = 0, t.count-1 do
						if t[i] == obj then 
							return true
						end
					end
				end
				return false
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__sortTable()" ReturnType="Table"
		Description="Returns a sorted table (indexed 1,2,...)." >
		<Constructor>table RC__sortTable(table t)</Constructor>
		<Formula>
			function RC__sortTable(t)
				local u,v,n,i,j,k,lo
				if t == nil then return nil,_error end
				if type(t) ~= type({}) then return '***',_warning end
				--Insertion sort, ok for small tables. TODO: Implement QuickSort for larger tables.
				u = {}
				v = {}
				n = 0
				while t[n+1] do
					n = n + 1
					table.insert(u,t[n])
				end		
				for i = 1, n do
					lo = math.huge
					for j = 1, n-i+1 do
						if u[j] &lt; lo then 
							lo = u[j]
							k = j 
						end
					end
					table.insert(v,table.remove(u,k)) --insert smallest number from u into v
				end
				return v
			end 
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__toKm()" ReturnType="String"
		Description="Converts input x [m] into mileage [km] with precision p (0..6), default precision is 3. E.g., 462371.637 => 462.372." >
		<Constructor>Double RC__toKm(Double x [, Int p])</Constructor>
		<Formula>
			function RC__toKm(x,p) 
				if p == nil then 
					if x == nil then
						return 0.0,_warning
					else
						p = 3
					end
				end
				p = math.floor(math.abs(p))
				if p &lt; 0 or p &gt; 6 then
					return "Precision ["..p.."] must be from 0 to 6, cannot format value ["..x.."]",_warning
				elseif p == 0 then return string.format("%.0f",math.floor((x+0.5*1e3)*1e-3)/1e0)
				elseif p == 1 then return string.format("%.1f",math.floor((x+0.5*1e2)*1e-2)/1e1)
				elseif p == 2 then return string.format("%.2f",math.floor((x+0.5*1e1)*1e-1)/1e2) 
				elseif p == 3 then return string.format("%.3f",math.floor((x+0.5*1e0)*1e0)/1e3)
				elseif p == 4 then return string.format("%.4f",math.floor((x+0.5*1e-1)*1e1)/1e4) 
				elseif p == 5 then return string.format("%.5f",math.floor((x+0.5*1e-2)*1e2)/1e5) 
				elseif p == 6 then return string.format("%.6f",math.floor((x+0.5*1e-3)*1e3)/1e6) 
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC__getDistance2D()" ReturnType="Double"
		Description="Returns the Euclidian distance in the XY plane between inputs p1 and p2, each being geoCoord or table {['X']=x,['Y']=y}. p2 is by default the calling object. Z's are ignored." >
		<Constructor>Double RC__getDistance2D(Point p1 [,Point p2])</Constructor>
		<Formula>
			function RC__getDistance2D(p1,p2) 
				local x1,x2,y1,y2
				if p1 == nil then 
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
				elseif p1.X then 
					x1 = p1.X
					y1 = p1.Y
				else
					return 0,_warning,_info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					-- Ordinary RailwayPlacedObject
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
				elseif p2.X then 
					x2 = p2.X
					y2 = p2.Y
				else
					return 0,_warning,_info("Second point has no X coordinate.")
				end
				return math.sqrt(math.pow(x2-x1,2) + math.pow(y2-y1,2))
			end
        </Formula>
	</LuaFunction>


	
	<LuaFunction Name="RC__getDistance3D()" ReturnType="Double"
		Description="Returns the Euclidian distance in XYZ space between inputs p1 and p2, each being geoCoord or table {['X']=x,['Y']=y,['Z']=z}. p2 is by default the calling object. Z's are 0 if missing." >
		<Constructor>Double RC__getDistance3D(Point p1 [,Point p2])</Constructor>
		<Formula>
			function RC__getDistance3D(p1,p2) 
				local x1,x2,y1,y2,z1,z2
				-- This code will work both for railML geoCoord entities and for tables using "X", "Y" and "Z" as indices. 
				if p1 == nil then
					return 0,_warning --bad args
				elseif p2 == nil then
					p2 = this
				end
				if p1.geoCoord then 
					x1 = p1.geoCoord.X
					y1 = p1.geoCoord.Y
					z1 = p1.geoCoord.Z
				elseif p1.X then 
					x1 = p1.X
					y1 = p1.Y
					z1 = p1.Z == nil and 0 or p1.Z
				else
					return 0,_warning,_info("First point has no X coordinate.")
				end
				if p2.geoCoord then 
					x2 = p2.geoCoord.X
					y2 = p2.geoCoord.Y
					z2 = p2.geoCoord.Z
				elseif p2.X then 
					x2 = p2.X
					y2 = p2.Y
					z2 = p2.Z == nil and 0 or p2.Z
				else
					return 0,_warning,_info("Second point has no X coordinate.")
				end
				return math.sqrt(math.pow(x2-x1,2) + math.pow(y2-y1,2) + math.pow(z2-z1,2))
			end
        </Formula>
	</LuaFunction>


	
<!--========================================================================================================
    RC common Lua, general but still railway-specific issues, present in any railway administration
	NB! These Lua functions shall not rely on RailCOMPLETE custom-specific attributes, only inherent ones.
=========================================================================================================-->
	<LuaFunction Name="RC_com_getNearestEntireKm()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when also half km is to be shown, e.g., 461.749 => 461 (half km is 5) and 461.750 => 462 (half km is 0)." >
		<Constructor>Int RC_com_getNearestEntireKm([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestEntireKm(obj)
				if obj == nil then
					obj = this
				end
				return math.floor(math.floor((obj.ReferenceMileage/500)+.5)/2)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getNearestEntireKm2()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when the half km is not to be shown, e.g., 461.749 => 462 (no half km) and 461.750 => 462 (no half km)." >
		<Constructor>Int RC_com_getNearestEntireKm2([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestEntireKm2(obj)
				if obj == nil then
					obj = this
				end
				return math.floor(math.floor(obj.ReferenceMileage/1000 + 0.5))
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getNearestHalfKm()" ReturnType="String"
		Description="Returns object's reference mileage's half km (0 or 5), e.g., 461.750 => 0 (whole km is 461) and 462.372 => 5 (whole km is 462)." >
		<Constructor>Int RC_com_getNearestHalfKm([RailwayPlacedObject obj])</Constructor>
		<Formula>
			function RC_com_getNearestHalfKm(obj)
				if obj == nil then
					obj = this
				end
				return (math.floor((obj.ReferenceMileage/500)+0.5)%2)*5
			end
		</Formula>
	</LuaFunction>
	
	
	
	<LuaFunction Name="RC_com_getLabelItem1()" ReturnType="String"
		Description="Returns the ReferenceMileage, formated as Km.&lt;value&gt;, for the label's own insertion point." >
		<Constructor>String RC_com_getLabelItem1()</Constructor>
		<Formula>
			function RC_com_getLabelItem1()
				return "Km."..RC__toKm(referenceMileage,3)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getLabelItem2()" ReturnType="String"
		Description="Returns a list consisting of the Code for each item related to the label (labels can relate to anything)." >
		<Constructor>String RC_com_getLabelItem2()</Constructor>
		<Formula>
			function RC_com_getLabelItem2()
				local r,n,s,i
				s = "Er etikett for anything"
				r,n = RC__getCollectionOfRelatedObjects(s)
				if n == 0 then 
					return "UNFINISHED - Relate with '"..s.."'."
				else
					t = "("..r[0].code
					for i = 1, n-1 do
						t = t..", "..r[i].code
					end
					return t..")"
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="RC_com_getLabelItem3()" ReturnType="String"
		Description="Returns the reference alignment Code for the label itself (not for a related item)." >
		<Constructor>String RC_com_getLabelItem3()</Constructor>
		<Formula>
			function RC_com_getLabelItem3()
				return "(Ref. "..referenceAlignment.code..")"
			end
		</Formula>
	</LuaFunction>



    <LuaFunction Name="RC_com_getAreasOfVariant()" ReturnType="Collection of RcArea"
		Description="Returns a count and a collection of visible areas of the given variant, enclosing the object." >
        <Constructor>Int, Collection of RcArea RC_com_getAreasOfVariant(String areaVariantName [, String guidString])</Constructor>
        <Formula>
			function RC_com_getAreasOfVariant(areaVariantName, guidString)
				local obj = guidString and getObjectFromId(guidString) or this
				local areas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:match(areaVariantName) end)
				return areas.count,areas
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
	The old railML property 'ocpStationRef' has been set to Browsable = false in C#, to HIDE IT from users.
	Do NOT try to assign values to it (this is possible even if it does not show up in RC-ManageProperties).
	Instead, use our own ocpStationReference property, which expects a string.
=========================================================================================================-->
		<!-- <xpp:expand select="RC_com_SET_OCP_STATION_REFERENCE" /> -->
<xpp:define name="RC_com_SET_OCP_STATION_REFERENCE" >
	<xpp:bloc>
		<LuaExpression Name="ocpStationReference" ><Formula>RC_com_getOcpStationReference()</Formula></LuaExpression>
	</xpp:bloc>
</xpp:define>

    <LuaFunction Name="RC_com_getOcpStationReference()" ReturnType="ObjRef"
		Description="Returns an object reference for the current Operation Control Point (OCP) area, or nil if not contained in any (visible) OCP area." >
        <Constructor>ObjRef RC_com_getOcpStationReference()</Constructor>
		<Formula>
			function RC_com_getOcpStationReference()
				local OcpAreas = RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				return getCollectionLength(OcpAreas) == 0 and "" or OcpAreas[0] --a GUID string.
			end
        </Formula>
    </LuaFunction>
	
	<LuaFunction Name="RC_com_getOcpStationRef()" ReturnType="ObjRef" 
	Description="Included for backwards compatilbility. Calls RC_com_getOcpStationReference(), which returns an ObjRef and not a GUID string as mandataed by railML." HideFromUser="false" >
		<Constructor>ObjRef RC_com_getOcpStationRef()</Constructor>
		<Formula>
			function RC_com_getOcpStationRef()
				return RC_com_getOcpStationReference()
			end
       </Formula>
	</LuaFunction>



	<LuaFunction Name="RC_com_getOcpCode()" ReturnType="String"
		Description="Returns the code property for the Operation / Control Point (OCP) area surrounding the object." >
        <Constructor>String RC_com_getOcpCode([Reference obj])</Constructor>
		<Formula>
			function RC_com_getOcpCode(obj)
				local OcpAreas,n
				obj = obj or this
				local OcpAreas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				n = getCollectionLength(OcpAreas)
				if n == 0 then 
					return "(UNFINISHED - No 'OCP område' area enclosing object.)"
				elseif n == 1 then
					return OcpAreas[0].code
				else
					return "(*** Multiple 'OCP område' areas enclosing object ["..RC__identify(OcpAreas[0])..", "..RC__identify(OcpAreas[1]).." ...]."
				end
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
    RC discpline-dependent Lua, but present in any railway administration
=========================================================================================================-->
<!--========================================================================================================
	Signaling
=========================================================================================================-->
 

	
<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>
  <FoulingPointSetting Name="1 Ny bane, tog/*" 
  MaxSearchLength="200" 
  LuaFunctionName="NOBN_trk_getFoulingPointDistanceTrainNew" 
  FoulingPointGraphicsType="0" />
  <FoulingPointSetting Name="2 Ny bane, skift/skift" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceTrainExisting" FoulingPointGraphicsType="0" />
  <FoulingPointSetting Name="3 Eks. bane, tog/*" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceShuntingNew" FoulingPointGraphicsType="0" />
  <FoulingPointSetting Name="4 Eks. bane, skift/skift" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceShuntingExisting" FoulingPointGraphicsType="0" />

  <LuaFunction Name="NOBN_trk_getFoulingPointDistanceTrainNew()" ReturnType="Double" Description="Returns fouling point distance for new line's switch when one or both legs carry train traffic." HideFromUser="false">
    <Constructor>Double NOBN_trk_getFoulingPointDistanceTrainNew(fpCandidate,branchPath,trunkPath,branchingLeft)</Constructor>
    <Formula>
			function NOBN_trk_getFoulingPointDistanceTrainNew(fpCandidate,branchPath,trunkPath,branchingLeft)
				return math.max(4.000, 2.120 + 1.700 + 0.100 + NOBN_trk_getFoulingPointLocalContribution(fpCandidate,branchPath,trunkPath,branchingLeft))
			end
		</Formula>
  </LuaFunction>
  <LuaFunction Name="NOBN_trk_getFoulingPointDistanceTrainExisting()" ReturnType="Double" Description="Returns fouling point distance for existing line's switch when one or both legs carry train traffic." HideFromUser="false">
    <Constructor>Double NOBN_trk_getFoulingPointDistanceTrainExisting(fpCandidate,branchPath,trunkPath,branchingLeft)</Constructor>
    <Formula>
			function NOBN_trk_getFoulingPointDistanceTrainExisting(fpCandidate,branchPath,trunkPath,branchingLeft)
				return math.max(0.000, 2.120 + 1.700 + 0.100 + NOBN_trk_getFoulingPointLocalContribution(fpCandidate,branchPath,trunkPath,branchingLeft))
			end
		</Formula>
  </LuaFunction>
  <LuaFunction Name="NOBN_trk_getFoulingPointDistanceShuntingNew()" ReturnType="Double" Description="Returns fouling point distance for new line's switch when no legs carry train traffic." HideFromUser="false">
    <Constructor>Double NOBN_trk_getFoulingPointDistanceShuntingNew(fpCandidate,branchPath,trunkPath,branchingLeft)</Constructor>
    <Formula>
			function NOBN_trk_getFoulingPointDistanceShuntingNew(fpCandidate,branchPath,trunkPath,branchingLeft)
				return math.max(4.000, 2.120 + 1.700 - 0.100 + NOBN_trk_getFoulingPointLocalContribution(fpCandidate,branchPath,trunkPath,branchingLeft))
			end
		</Formula>
  </LuaFunction>
  <LuaFunction Name="NOBN_trk_getFoulingPointDistanceShuntingExisting()" ReturnType="Double" Description="Returns fouling point distance for existing line's switch when no legs carry train traffic." HideFromUser="false">
    <Constructor>Double NOBN_trk_getFoulingPointDistanceShuntingExisting(fpCandidate,branchPath,trunkPath,branchingLeft)</Constructor>
    <Formula>
			function NOBN_trk_getFoulingPointDistanceShuntingExisting(fpCandidate,branchPath,trunkPath,branchingLeft)
				return math.max(0.000, 2.120 + 1.700 - 0.100 + NOBN_trk_getFoulingPointLocalContribution(fpCandidate,branchPath,trunkPath,branchingLeft))
			end
		</Formula>
  </LuaFunction>
  <LuaFunction Name="NOBN_trk_getFoulingPointLocalContribution()" ReturnType="Double" Description="Returns fouling point distance for existing line's switch when no legs carry train traffic." HideFromUser="false">
    <Constructor>Double NOBN_trk_getFoulingPointLocalContribution(fpCandidate,branchPath,trunkPath,branchingLeft)</Constructor>
    <Formula>
function NOBN_trk_getFoulingPointLocalContribution(
		fpCandidate,	--Point2d: a candidate fouling point, from which we will calcluate the instantaneous required FP separation.
		trunkId,		--RcAlignment.id: the candidate trunk path's GUID (containing through the alignment to which the switch belongs).
		branchId,		--RcAlignment.id: the candidate branch path's GUID (a path is a transient alignment winding through many alignments).
		branchingLeft	--Boolean: switch object's railML property connectionCourse=='left'.
	)
	
	function Kinner(R) return 81.0 / (2*R)
		--First term of a Taylor series, b^2/2r, assuming b=9 meter (standard Bane NOR assumption for halfAxleSeparation)
		--See ..\Google Drive\RC_DEV\I - Issues\Attachments\2020-03-17 Taylor series expansion for RC-DisplayEnvelope (issue #6338)
	end

	function Kouter(R)
		--First term of a Taylor series, (2bc+c^2)/2r, assuming c=3 meter (standard Bane NOR assumption for tail/nose extension from end/nose axle)
		--See ..\Google Drive\RC_DEV\I - Issues\Attachments\2020-03-17 Taylor series expansion for RC-DisplayEnvelope (issue #6338)
		return 63.0 / (2*R)
	end

	--Retrieve alignment info:
	local trunkInfo = getAlignmentInfo(fpCandidate.X, fpCandidate.Y, trunkId)
	local branchInfo = getAlignmentInfo(fpCandidate.X, fpCandidate.Y, branchId)

	--Deduce contributions from inner/outer curves:
	local trunkIsOuter = false
	local trunkRadius = math.huge
	if trunkInfo.Segment.Type ~= "Straight" then
		trunkIsOuter = ((trunkInfo.SignedRadius &gt; 0) == (not branchingLeft))
		trunkRadius = trunkInfo.CurveRadius
	end
	local branchIsOuter = false
	local branchRadius = math.huge
	if branchInfo.Segment.Type ~= "Straight" then
		--'Curve' or 'Clothoid'. Signed radius is positive for left-curving track.
		branchIsOuter = ((branchInfo.SignedRadius &gt; 0) == branchingLeft)
		branchRadius = branchInfo.CurveRadius
	end
	local curvatureContribution = (trunkIsOuter and Kouter(trunkRadius) or Kinner(trunkRadius)) 
								+  (branchIsOuter and Kouter(branchRadius) or Kinner(branchRadius))
								
	--Deduce contributions from cant, checking whether the cants lean 'net' towards each other or not.
	local trunkCant = RC__isNan(trunkInfo.Cant) and 0.0 or trunkInfo.Cant/1000.0
	local branchCant = RC__isNan(branchInfo.Cant) and 0.0 or branchInfo.Cant/1000.0
	local cantContribution = 0.0
	local tr = trunkInfo.CantRotation == nil and "CW" or trunkInfo.CantRotation --Treat as "CW" if no cant present
	local br = branchInfo.CantRotation == nil and "CW" or branchInfo.CantRotation --Treat as "CW" if no cant present
	if branchingLeft then 
		if br == "CW" and tr == "CCW" then cantContribution = 2.3 * (branchCant + trunkCant) --both leaning towards each other
		elseif br == "CW" and tr == "CW" then cantContribution = 2.3 * math.max(0,branchCant - trunkCant) --both leaning to the right
		elseif br == "CCW" and tr == "CCW" then cantContribution = 2.3 * math.max(0,trunkCant - branchCant) --both leaning to the left
		elseif br == "CCW" and tr == "CW" then cantContribution = 0.0 --both leaning away from each other
		else return 98.0 --error
		end
	else --turnout's right leg is the branch track  
		if br == "CW" and tr == "CCW" then cantContribution = 0.0 --both leaning away from each other
		elseif br == "CW" and tr == "CW" then cantContribution = 2.3 * math.max(0,trunkCant - branchCant) --both leaning to the right
		elseif br == "CCW" and tr == "CCW" then cantContribution = 2.3 * math.max(0,branchCant - trunkCant) --both leaning to the left
		elseif br == "CCW" and tr == "CW" then cantContribution = 2.3 * (branchCant + trunkCant) --both leaning towards each other
		else return 99.0 --error
		end
	end

	return curvatureContribution + cantContribution
end
		</Formula>
  </LuaFunction>

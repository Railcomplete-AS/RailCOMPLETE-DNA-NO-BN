<!--========================================================================================================

    NO-BN-Foulingpoint.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml"/>.

	Copyright (c) 2015-2024 Railcomplete AS, Norway, NO916118503
	
=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
	TRACK / SIGNALLING
	Fouling point settings
	
	MaxSearchLength				The max distance [m] from a switch's stock rail joint to search for fouling point(s).
								All possible selections of two paths extending from the switch will be searched.
	
	LuaFunctionName				The function which will be called to compute the fouling point position.

	FoulingPointGraphicsType	The type of graphics displayed in RailCOMPLETE as visible graphics.
			
	Type 0	Draws a line from FP to its projection in each track and adds a Ø1.0 m circle at the FP. 
	Type 1	Draws a line from FP to its projection in each track and adds a Ø1.0 m and a Ø1.2 circle at the FP.
	Type 2	Draws a line from FP half-way to its projection in each track and adds a Ø1.0 m circle at the FP. 
	Type 3	Draws a line from FP half-way to its projection in each track and adds a Ø1.0 m and a Ø1.2 m circle at the FP.
	Type 4	Draws a single line between the FP's projections in the two tracks 
	Type 5	Draws a double line between the FP's projections in the two tracks, the line spacing being 0.1 m.
	
=========================================================================================================-->
	<!-- Ignore the last boolean argument passed on from the RC engine, (shunting ::= type=='sidingTrack' for both alignments) -->
	<FoulingPointSetting Name="1 Ny bane, tog/*" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceNewTrain" FoulingPointGraphicsType="0"
		SetAsDefault="true"/>
	<FoulingPointSetting Name="2 Ny bane, skift/skift" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceNewShunting" FoulingPointGraphicsType="1"/>
	<FoulingPointSetting Name="3 Eks. bane, tog/*" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceExistingTrain" FoulingPointGraphicsType="2"/>
	<FoulingPointSetting Name="4 Eks. bane, skift/skift" MaxSearchLength="200" LuaFunctionName="NOBN_trk_getFoulingPointDistanceExistingShunting" FoulingPointGraphicsType="3"/>
	
	<LuaFunction Name="NOBN_trk_getFoulingPointDistanceNewTrain()" 
		ReturnType="Double" 
		Description="Returns fouling point distance for new line's switch when one or both legs carry train traffic."
		HideFromUser="false">
		<Constructor>Double NOBN_trk_getFoulingPointDistanceNewTrain(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)</Constructor>
		<Formula>
			function NOBN_trk_getFoulingPointDistanceNewTrain(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)
				return math.max(4.000, 2.120 + 1.700 + 0.100 + NOBN_trk_getFoulingPointLocalContribution(foulingPointCandidate,path1,path2,path1IsLeftOfPath2))
			end
		</Formula>		
	</LuaFunction>
	
	<LuaFunction Name="NOBN_trk_getFoulingPointDistanceNewShunting()" 
		ReturnType="Double" 
		Description="Returns fouling point distance for new line's switch when no legs carry train traffic."
		HideFromUser="false">
		<Constructor>Double NOBN_trk_getFoulingPointDistanceNewShunting(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)</Constructor>
		<Formula>
			function NOBN_trk_getFoulingPointDistanceNewShunting(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)
				return math.max(4.000, 2.120 + 1.700 - 0.100 + NOBN_trk_getFoulingPointLocalContribution(foulingPointCandidate,path1,path2,path1IsLeftOfPath2))
			end
		</Formula>		
	</LuaFunction>
	
	<LuaFunction Name="NOBN_trk_getFoulingPointDistanceExistingTrain()" 
		ReturnType="Double" 
		Description="Returns fouling point distance for existing line's switch when one or both legs carry train traffic."
		HideFromUser="false">
		<Constructor>Double NOBN_trk_getFoulingPointDistanceExistingTrain(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)</Constructor>
		<Formula>
			function NOBN_trk_getFoulingPointDistanceExistingTrain(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)
				return math.max(0.000, 2.120 + 1.700 + 0.100 + NOBN_trk_getFoulingPointLocalContribution(foulingPointCandidate,path1,path2,path1IsLeftOfPath2))
			end
		</Formula>		
	</LuaFunction>

	<LuaFunction Name="NOBN_trk_getFoulingPointDistanceExistingShunting()" 
		ReturnType="Double" 
		Description="Returns fouling point distance for existing line's switch when no legs carry train traffic."
		HideFromUser="false">
		<Constructor>Double NOBN_trk_getFoulingPointDistanceExistingShunting(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)</Constructor>
		<Formula>
			function NOBN_trk_getFoulingPointDistanceExistingShunting(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)
				return math.max(0.000, 2.120 + 1.700 - 0.100 + NOBN_trk_getFoulingPointLocalContribution(foulingPointCandidate,path1,path2,path1IsLeftOfPath2))
			end
		</Formula>		
	</LuaFunction>

	<LuaFunction Name="NOBN_trk_getFoulingPointLocalContribution()" 
		ReturnType="Double" 
		Description="Returns the extra coach separation needed due to local curvatures (Kinner=81/2R, Kouter=63/2R) and to local cants (2.3*SignficantCantDifference)."
		HideFromUser="false">
		<Constructor>Double NOBN_trk_getFoulingPointLocalContribution(foulingPointCandidate,path1,path2,path1IsLeftOfPath2)</Constructor>
		<Formula>
			function NOBN_trk_getFoulingPointLocalContribution(
				foulingPointCandidate,	--Point2d: a candidate fouling point, from which we will calculate the instantaneous required FP separation.
				path1,					--RailwayPath: a structure containing a list of AlignmentIntervals, which is an interval on an alignment represented by the alignment's ObjectId, two positions, and a direction.
				path2,					--RailwayPath: a structure containing a list of AlignmentIntervals.
				path1IsLeftOfPath2		--Boolean: true iff path1 is to the left of path2 when vieweing the switch from the WCS positive Z axis, looking into the tip-of-tongues.
			)
			
				function Kinner(R) 
					--First term of a Taylor series, b^2/2r, assuming b=9 meter (standard Bane NOR assumption for halfAxleSeparation)
					--See \OneDrive - Railcomplete AS\V\I - Issues\Attachments\2020-03-17 Taylor series expansion for RC-DisplayEnvelope (issue #6338)
					return 81.0 / (2*R)
				end

				function Kouter(R)
					--First term of a Taylor series, (2bc+c^2)/2r, assuming c=3 meter (standard Bane NOR assumption for tail/nose extension from end/nose axle)
					--See \OneDrive - Railcomplete AS\V\I - Issues\Attachments\2020-03-17 Taylor series expansion for RC-DisplayEnvelope (issue #6338)
					return 63.0 / (2*R)
				end

				--Retrieve alignment geometry info:
				local path1Info = getAlignmentInfo(foulingPointCandidate.X, foulingPointCandidate.Y, path1)
				local path2Info = getAlignmentInfo(foulingPointCandidate.X, foulingPointCandidate.Y, path2)
				local t1 = path1Info.Segment.Type 
				local t2 = path2Info.Segment.Type 
				local cw1 = (path1Info.SignedRadius &gt; 0) --CW (true) or not CW (false)
				local cw2 = (path2Info.SignedRadius &gt; 0) --CW (true) or not CW (false)
				local r1 = math.abs(path1Info.SignedRadius) --Note: Reading path1Info.Radius fails for clothoids
				local r2 = math.abs(path2Info.SignedRadius) --Note: Reading path2Info.Radius fails for clothoids

				--Deduce contributions from inner/outer curves:
				local curveContribution = 0.0
				if path1IsLeftOfPath2 then
					if t1 ~= "Straight" then curveContribution = curveContribution + (cw1 and Kouter(r1) or Kinner(r1)) end
					if t2 ~= "Straight" then curveContribution = curveContribution + (cw2 and Kinner(r2) or Kouter(r2)) end
				else
					--path1 is right of path2
					if t1 ~= "Straight" then curveContribution = curveContribution + (cw1 and Kinner(r1) or Kouter(r1)) end
					if t2 ~= "Straight" then curveContribution = curveContribution + (cw2 and Kouter(r2) or Kinner(r2)) end
				end
											
				--Retrieve alignment superelevation info [mm], convert to [m]:
				local c1 = RC__isNan(path1Info.Cant) and 0.0 or path1Info.Cant/1000.0
				local c2 = RC__isNan(path2Info.Cant) and 0.0 or path2Info.Cant/1000.0
				local cr1 = path1Info.CantRotation == nil and "CW" or path1Info.CantRotation --Treat as "CW" if no cant present
				local cr2 = path2Info.CantRotation == nil and "CW" or path2Info.CantRotation --Treat as "CW" if no cant present

				--Deduce contributions from cant, checking whether the cants lean 'net' towards each other or not.
				local cantContribution = 0.0
				if path1IsLeftOfPath2 then 
					if cr1 == "CW" and cr2 == "CCW" then cantContribution = 2.3 * (c1+c2) --both leaning towards each other
					elseif cr1 == "CW" and cr2 == "CW" then cantContribution = 2.3 * math.max(0,c1-c2) --both leaning to the right
					elseif cr1 == "CCW" and cr2 == "CCW" then cantContribution = 2.3 * math.max(0,c2-c1) --both leaning to the left
					elseif cr1 == "CCW" and cr2 == "CW" then cantContribution = 0.0 --both leaning away from each other
					else return 98.0 --error
					end
				else
					--path1 is right of path2
					if cr1 == "CW" and cr2 == "CCW" then cantContribution = 0.0 --both leaning away from each other
					elseif cr1 == "CW" and cr2 == "CW" then cantContribution = 2.3 * math.max(0,c2-c1) --both leaning to the right
					elseif cr1 == "CCW" and cr2 == "CCW" then cantContribution = 2.3 * math.max(0,c1-c2) --both leaning to the left
					elseif cr1 == "CCW" and cr2 == "CW" then cantContribution = 2.3 * (c1+c2) --both leaning towards each other
					else return 99.0 --error
					end
				end

				return curveContribution + cantContribution
			end
		</Formula>		
	</LuaFunction>



<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>
<!--========================================================================================================

    NO-BN-National-Lua.xml
	
	Include in DNA file using XPPq XML preprocessor directive <xpp:expand href="fileName.xml"/>.

	Copyright (c) 2015-2024 Railcomplete AS, Norway, NO916118503

=========================================================================================================-->
<xpp:bloc>



<!--========================================================================================================
	NOBN_xxx_YyyyZzzz()
	xxx = one the official discipline's abbreviations, see XML root file.
	
	This file contains Lua functions which either has a text item being subject to translation into local 
	language, or which uses	one or more resources which exist only when the relevant DNA is present (custom
	properties, text attributes, Lua functions, Lua name aliases etc).
	
	The contents of this file are meant to be line-by-line identical to other DNA's, except for text items.
	The Lua code contained herein is supposed to use only intrinsic names for custom properties, and these
	are to be written exclusively in English, to ease maintenance across different administrations' DNAs.
=========================================================================================================-->



<!--========================================================================================================
	NOBN_com_YyyyZzzz
	Lua functions common to two or more railway disciplines.
=========================================================================================================-->
	<LuaFunction Name="NOBN_com_mileageIncreasesTowardsLeft()" ReturnType="String"
		Description="Returns 'true' if, and only if, the alignment's local tangent direction of the calling point object has kilometration increasing towards left in the current User Coordinate System. Use the context menu's 'RailCOMPLETE Screen Orientation' to set a new UCS, then refresh the affected point objects.">
		<Signature>String NOBN_com_mileageIncreasesTowardsLeft()</Signature>
		<Formula>
			function NOBN_com_mileageIncreasesTowardsLeft()
				local acsYaxisTangent = getAlignmentInfo().Tangent
				local acsYaxisWcsAngle = math.deg(math.atan(acsYaxisTangent.Y,acsYaxisTangent.X))
				local cs = DocumentData.Document.Editor.CurrentUserCoordinateSystem.CoordinateSystem3d
				local ucsXaxisWcsAngle = math.deg(math.atan(cs.Xaxis.Y,cs.Xaxis.X))
				local diffAngModulo360 = (acsYaxisWcsAngle - ucsXaxisWcsAngle) % 360
				return diffAngModulo360 &gt; 90 and diffAngModulo360 &lt; 270
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_setStage()" ReturnType="String"
		Description="Returns the object's layer's 'stageEntry-stageExit' pattern (two 4-digit numbers 'nnnn-mmmm'). If not found, a '?' is returned. See also command RC-ManageStagesUsingLayerNames.">
		<Signature>String NOBN_com_setStage()</Signature>
		<Formula>
			function NOBN_com_setStage()
				return Layer:match(".+(%d%d%d%d%-%d%d%d%d).*") or "?"
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_getOcpCode()" ReturnType="String"
		Description="Returns the code property for the Operation / Control Point (OCP) area surrounding the given object.">
        <Signature>String NOBN_com_getOcpCode([Reference obj])</Signature>
		<Formula>
			function NOBN_com_getOcpCode(obj)
				obj = obj or this
				local OcpAreas = obj.RcArea:filter(function (x) return x:isVisible() and x.Variant:lower():match("ocp") end)
				local n = getCollectionLength(OcpAreas)
				if n == 0 then 
					return "",_info("UNFINISHED - No OCP area enclosing the object."),_unfinished
				elseif n == 1 then
					return OcpAreas[0].code,_noSymbol
				else
					return "?",_info("WARNING - Multiple OCP areas are enclosing the object ["..RC__identify(OcpAreas[0])..", "..RC__identify(OcpAreas[1]).." ...]."),_warning
				end
			end
        </Formula>
    </LuaFunction>



	<LuaFunction Name="NOBN_com_setSymbolFrame()" ReturnType="String"
		Description="Checks the object's modelcheck attributes for status symbols such as warnings and errors and turns on the corresponding symbol frame ([no frame]/_unfinished/_warning/_error).">
		<Signature>String NOBN_com_setSymbolFrame()</Signature>
		<Formula>
			function NOBN_com_setSymbolFrame()
				-- More symbol frame types may be available - see the appropriate Style Definitions file.
				local language = 2 -- 1:English, 2:Norwegian, 3:French, 4:German
				local frames = { 
					HISTORIC	= { "Historic",				"Historic",				"Historique",			"Historisch"			},
					UNFINISHED	= { "Unfinished",			"Unfinished",			"Incomplet",			"Unvollständig"			},
					WARNING		= { "Warning",				"Warning",				"Avertissement",		"Warnung"				},
					ERROR		= { "Error",				"Error",				"Erreur",				"Fehler"				},
					REQUESTED	= { "Requested",			"Requested",			"Demandée",				"Nachgefragt"			},
					GRANTED		= { "Granted",				"Granted",				"Accordée",				"Zugesagt"				},
					SECTION_TAG	= { "section",				"avsnitt",				"zone",					"Abschnitt"				},
					SEGMENT_TAG = { "Segment",				"Segment",				"Segment",				"Segment"				},
					SECTION		= { "SymbolFrame-R2.75",	"Symbolramme-R2.75",	"",						""						},
					SEGMENT		= { "SymbolFrame-R2.75",	"Symbolramme-R2.75",	"CadreSymbole-R2.75",	"Symbolrahmen-R2.75"	}
				}
				--Priority: Show HISTORIC then UNFINISHED then ERROR then WARNING then OTHERs then NO_FRAME
				-- By convention, historic layers have names starting with a double 'at' character '@@':
				if (tostring(Layer):sub(1,2) == '@@') then
					return frames.HISTORIC[language]
				end
			
				--Check code and name for keywords:
				--(inhibit evaluation of 'code' and 'name', since RC will not allow us to nest Lua calls too deep, 5 levels max)
				local thisCode = getPropertyValue("code")
				local thisName = getPropertyValue("name")
			
				local t = frames["UNFINISHED"][language]
				if tostring(thisCode):upper():match(t:upper()) or tostring(thisName):upper():match(t:upper()) then 
					return t
				end
			
				t = frames["WARNING"][language]
				if tostring(thisCode):upper():match(t:upper()) or tostring(thisName):upper():match(t:upper()) then 
					return t
				end
			
				t = frames["ERROR"][language]
				if tostring(thisCode):upper():match(t:upper()) or tostring(thisName):upper():match(t:upper()) then 
					return t
				end

				--Then scan the modelchecks for unfished items, warnings or errors - but suppress the symbolframe if a derogation
				--has been requested or has been granted:
				local modelChecks = LuaExpressions:filter(function(x) return x.IsModelCheck end)
				if (modelChecks:filter(function(x) return x.Symbol == "_unfinished" end).Count &gt; 0) then
					return frames.UNFINISHED[language]
				elseif Derogation == "REQUESTED" then return frames.REQUESTED[language]
				elseif Derogation == "GRANTED" then return frames.GRANTED[language]
				elseif (modelChecks:filter(function(x) return x.Symbol == "_error" end).Count &gt; 0) then
					return frames.ERROR[language] --Deviating, no derogation requested or granted
				elseif (modelChecks:filter(function(x) return x.Symbol == "_warning" end).Count &gt; 0) then
					return frames.WARNING[language] --Deviating, no derogation requested or granted
				else
					--do nothing, fall through to next check
				end
			
				--Then scan the various relations and their cardinalities to check for unsatisfied minimum requirements:
				local ss = Relations.SourceSpace
				local rel = Relations.ObjectRelations
				local nRel = getCollectionLength(rel)
				for i = 0,nRel-1 do
					local r = rel[i]
					--[[
						Example - object is a high voltage switch (Norw: Bryter)
						r = this.Relations.Objectrelations
						r.RelationPromptText			rel_HvSwitch_Has_HvSwitchActuator
						r.Relation.RelatesTo.Min		0
						r.Relations						Collection is empty (no forward relation exists)
						r.ReverseRelationPromptText		rel_HvSwitchActuator_Actuates_HvSwitch
						r.Relation.ReverseRelatesTo.Min	1
						r.ReverseRelations				Name-of-related-object(1 reverse relation found)
					--]]
					--[[
						Note: We might have relation prompt texts such as "Is xyzzy for xyzzy_charger/multi_xyxxz/buzzer",
						or just "Is xyzzy for multi_xyxxz", or just "Is xyzzy for buzzer". Don't accept partial word match.
						I.e., our search pattern must be followed by either slash '/' or end-of-line '$'.
						Also, we must start by substitution of all '-' with '%-', since '-' is a special character for match().
					--]]
					local ss1 = ss:gsub("%-","%%-").."/" 
					local ss2 = ss:gsub("%-","%%-").."$"
					local t1 = (r.ReverseRelationPromptText:match(ss1) == ss)
					local t2 = (r.ReverseRelationPromptText:match(ss2) == ss)
					--if true then return "Someone points to me = ".. ((t1 or t2) and "Yes" or "No") end
					if t1 or t2 then
						local nForward = getCollectionLength(r.Relations)
						local minForward = r.Relation.RelatesTo.Min
						--if true then return nRel,i,"---",nForward,minForward,r.RelationPromptText,"---",nReverse,minReverse,r.ReverseRelationPromptText end
						if nForward &lt; minForward then return frames.UNFINISHED[language] end
					end
			
					local t3 = (r.RelationPromptText:match(ss1) == ss)
					local t4 = (r.RelationPromptText:match(ss2) == ss)
					--if true then return "I point to someone = ".. ((t3 or t4) and "Yes" or "No") end
					if t3 or t4 then
						local nReverse = getCollectionLength(r.ReverseRelations)
						local minReverse = r.Relation.ReverseRelatesTo.Min
						--if true then return nRel,i,"---",nForward,minForward,r.RelationPromptText,"---",nReverse,minReverse,r.ReverseRelationPromptText end
						if nReverse &lt; minReverse then return frames.UNFINISHED[language] end
					end
				end
			
				--Now, look for derogations or else look for unsatisfied modelchecks:
				modelChecks = LuaExpressions:filter(function(x) return x.IsModelCheck end)
				if Derogation == "REQUESTED" then return frames.REQUESTED[language]
				elseif Derogation == "GRANTED" then return frames.GRANTED[language]
				elseif (modelChecks:filter(function(x) return x.Symbol == "_error" end).Count &gt; 0) then
					return frames.ERROR[language] --Deviating, no derogation requested or granted
				elseif (modelChecks:filter(function(x) return x.Symbol == "_warning" end).Count &gt; 0) then
					return frames.WARNING[language] --Deviating, no derogation requested or granted
				elseif (modelChecks:filter(function(x) return x.Symbol == "_unfinished" end).Count &gt; 0) then
					return frames.UNFINISHED[language]
				else
					--do nothing, fall through to next check
				end
			
				--If no problems remain, go on to show 'normal behaviour' frame for objects that feature a frame:
				--Deal with axle counter special section objects (the layer name will depend on the DNA in use):
				if RcType:upper():match(frames.SECTION_TAG[language]:upper()) then 
					return frames.SECTION[language]
				end
			
				--Deal with characteristic point special section objects (the layer name will depend on the DNA in use):
				if RcType:upper():match(frames.SEGMENT_TAG[language]:upper()) then 
					return frames.SEGMENT[language]
				end
			
				--Nothing recognised:
				return "" --no frame
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_com_getLabelItem1()" ReturnType="String"
		Description="Returns the ReferenceMileage, formated as Km.&lt;value&gt;, for the label's own insertion point.">
		<Signature>String NOBN_com_getLabelItem1()</Signature>
		<Formula>
			function NOBN_com_getLabelItem1()
				return "Km."..NOBN_trk_toKm(ReferenceMileage,3)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getLabelItem2()" ReturnType="String"
		Description="Returns a list consisting of the Code for each item related to the label (labels can relate to anything).">
		<Signature>String NOBN_com_getLabelItem2()</Signature>
		<Formula>
			function NOBN_com_getLabelItem2()
				local s = rel_Label_AppliesTo_Anything
				local r,n = getRelatedObjects(s)
				if n == 0 then
					return "UNFINISHED - Relate with '"..s.."'."
				else
					local t = "("..r[0].code
					for i = 1, n-1 do
						t = t..", "..r[i].code
					end
					return t..")"
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_com_getLabelItem3()" ReturnType="String"
		Description="Returns the reference alignment's 'code' property for the label itself (not for a related item).">
		<Signature>String NOBN_com_getLabelItem3()</Signature>
		<Formula>
			function NOBN_com_getLabelItem3()
				return "(Ref. "..ReferenceAlignment.code..")"
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_assistAssignEarthingAlignment()" ReturnType="AlignmentRef"
		Description="Suggests an earthing alignment reference for an object, based on its RcType, its Variant and its surroundings. The function assumes that rails of RcType '&quot;..rctype_InnerRailAndInsulation..&quot;' are present and have been divided already into insulated and non-insulated sections.">
        <Signature>AlignmentRef NOBN_com_assistAssignEarthingAlignment([ObjRef obj])</Signature>
		<Formula>
			function NOBN_com_assistAssignEarthingAlignment(obj)
				--TODO: Consider replacing "Red/Green" filter with a downwards search for track insulation with railML property 'left', 'right', 'both', 'none' (in associated track).
				if obj == nil then obj = this end
			
				--Gauge tolerance when looking for rails belonging to the same track:
				local gaugeTolerance = 0.030 --[m]
				--If not too far away, we prefer a dedicated earth rail over double insulated track, where you should consider not earthing to both rails:
				local railDistanceTolerance = 6.000  --[m]
			
				if EarthingMethod == "None" then 
					return
			
				elseif EarthingMethod == "Unknown" then 
					return _info("UNFINISHED - Earthing method is Unknown, cannot deduce EarthingAlignment.")
					
				elseif EarthingMethod == "Rail" then
					local r = getNearbyAlignments(obj, rctype_InnerRailAndInsulation):filter(function (x) return x:getPropertyValue("Color"):upper() == "RED" end)
					local d
					if getAlignmentInfo(r[0].id,obj).NormalProjectionExists then
						--Find distance sideways to closest insulated rail:
						d = getAlignmentInfo(r[0].id,obj).DistanceToAlignment
					else
						--No normal projection exists onto insulated rail, so look for  distance to closest start/end of closest insulated rail:
						d = math.min(RC__getDistance2D(r[0].RcAlignment.StartPoint,obj),RC__getDistance2D(r[0].RcAlignment.EndPoint,obj))
					end
					if math.abs(d) &lt;= railDistanceTolerance then
						--If distance to insulated rail is reasonably short, then use it now...
						return r[0]
					else 
						--...otherwise, check if the two closest *un*insulated rails belong to the same track, asuuming both are (through use of impedances) carrying return current:
						--Btw, this proceudre fails if the object is between two tracks where insulated rail distances are just above the tolerance, so that the two closest 
						--return rails belong to two *different* railway tracks.
						r = getNearbyAlignments(rctype_InnerRailAndInsulation):filter(function (x) return getAlignmentInfo(x.id).NormalProjectionExists and x.color:upper() == "GREEN" end)
						local d0 = getAlignmentInfo(r[0].id,obj).DistanceToAlignment
						local d1 = getAlignmentInfo(r[1].id,obj).DistanceToAlignment
						if math.abs(math.abs(d0-d1) - r[0].AlignmentSystem.AlignmentGauge) &lt; gaugeTolerance then
							--Pick closest un-insulated rail, although it is 'bad taste' if we thereby end up
							--with objects earthed to both rails within one double-insulated track circuit:
							return r[0]
						else
							return _info("Search for nearby rails suitable for protective earthing failed (i.e., rails of type '"..rctype_InnerRailAndInsulation.."', carrying return current).")
						end
					end
			
				elseif EarthingMethod == "Wire" then 
					local r = getNearbyAlignments(obj, rctype_EarthingConductor)
					return r[0]
					
				elseif EarthingMethod == "Object" then 
					--Just return - and let similar Lua code for the 'EarthingObject' reference property do the job:
					return _noSymbol
				end
			end
        </Formula>
    </LuaFunction>



	<LuaFunction Name="NOBN_com_assistAssignEarthingObject()" ReturnType="ObjectRef"
		Description="Suggests an earthing object reference for an object, based on its RcType, its Variant and its surroundings. The function assumes that there is an object nearby that can offer protective earth.">
        <Signature>AlignmentRef NOBN_com_assistAssignEarthingObject([ObjRef obj])</Signature>
		<Formula>
			function NOBN_com_assistAssignEarthingObject(obj)
				if obj == nil then obj = this end
				local earthingConnectionMaxLength = 10 --[m]
			
				if obj.EarthingMethod == "None" then 
					return _noSymbol
				
				elseif obj.EarthingMethod == "Unknown" then 
					return _noSymbol, _info("UNFINISHED - Earthing method is Unknown, cannot deduce EarthingObject.")
				
				elseif obj.EarthingMethod == "Rail" then
					return _noSymbol
				
				elseif obj.EarthingMethod == "Wire" then 
					return _noSymbol
				
				elseif obj.EarthingMethod == "Object" then 
					local npo = getNearbyPointObjects2D(earthingConnectionMaxLength,obj):filter
						(function (x)
							local em = x:getPropertyValue("EarthingMethod")
							local ea = x:getPropertyValue("EarthingAlignment")
							local eo = x:getPropertyValue("EarthingAlignment")
							return 
								((em == 'Rail' or em == 'Wire') and (ea and ea ~= obj))
								or
								((em == 'Object') and (eo and eo ~= obj))
						end)
					if getCollectionLength(npo) &gt; 0 then
						return npo[0]
					else 
						return _noSymbol,_error, _info("UNFINISHED - Earthing method is Object, but no suitable earth providing objects found.")
					end
					
				else
					-- Should not happen
					return nil, _info("ERROR - Bad Earthing Method.")
				end
			end
        </Formula>
    </LuaFunction>



	<LuaFunction Name="NOBN_com_assignEarthingLabelColor()" ReturnType="String"
		Description="Assigns the color for the permanent marking tag attached to earthing connector, deduced from the object's discipline.">
        <Signature>String NOBN_com_assignEarthingLabelColor([ObjRef obj])</Signature>
		<Formula>
			function NOBN_com_assignEarthingLabelColor(obj)
				obj = obj or this
				if     obj.Discipline == "Felles"						then return "7" --White
				elseif obj.Discipline == "Underbygning"					then return "7" --White
				elseif obj.Discipline == "Overbygning"					then return "7" --White
				elseif obj.Discipline == "Kontaktledning"				then return "1" --Red
				elseif obj.Discipline == "Signal"						then return "3" --Green
				elseif obj.Discipline == "Tele"							then return "2" --Yellow
				elseif obj.Discipline == "Lavspent"						then return "5" --Blue
				elseif obj.Discipline == "Skilt"						then return "7" --White
				else 
					return _error, "ERROR - Uncrecognized discipline ["..obj.Discipline.."]."
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_assistAssignEarthingLabelText()" ReturnType="String"
		Description="Suggests an earthing alignment label text for an object, based on its RcType, its Variant and its surroundings. The function assumes that the object already has a defined EarthingMethod and EarthingAlignment/EarthingObject.">
        <Signature>String NOBN_com_assistAssignEarthingLabelText([ObjRef obj])</Signature>
		<Formula>
			function NOBN_com_assistAssignEarthingLabelText(obj)
				if obj == nil then obj = this end
				if obj.EarthingMethod == "None" then 
					return ""
				elseif obj.EarthingMethod == "Object" then
					return RC__identify(obj.EarthingObject).." / "..RC__identify(obj)
				elseif obj.EarthingMethod == "Wire" then 
					return RC__identify(obj.EarthingAlignment).." / "..RC__identify(obj)
				elseif obj.EarthingMethod == "Rail" then 
					return RC__identify(obj.EarthingAlignment).." / "..RC__identify(obj)
				elseif obj.EarthingMethod == "Unknown" then 
					return "(?)".." / "..RC__identify(obj)
				else
					return _error, "ERROR - Bad Earthing Method ["..obj.EarthingMethod.."]."
				end
			end
        </Formula>
    </LuaFunction>



	<LuaFunction Name="NOBN_com_assistAssignEarthingPosBias()" ReturnType="Double"
		Description="Suggests an earthing alignment pos bias for an object, based on its earthing method and its surroundings. A non-zero bias moves the 'earthing landing point' along the earthing alignment.">
        <Signature>Double NOBN_com_assistAssignEarthingPosBias([ObjRef obj])</Signature>
		<Formula>
			function NOBN_com_assistAssignEarthingPosBias(obj)
				if obj == nil then obj = this end
				local offset = 1
				if obj.EarthingMethod == "Rail" then
					if getAlignmentInfo(obj.EarthingAlignment.id).NormalProjectionExists then
						return 0
					else 
						--Move earth connection a little past insulation along insulated rail's tangent direction (at start or end of rail): 
						local ps = obj.EarthingAlignment.RcAlignment.StartPoint
						local pe = obj.EarthingAlignment.RcAlignment.EndPoint
						local ds = RC__getDistance2D(ps,obj)
						local de = RC__getDistance2D(pe,obj)
						if ds &lt; de then
							local u = obj.EarthingAlignment.RcAlignment.StartTangent
							return ((ps.X-geoCoord.X)*u.X + (ps.Y-geoCoord.Y)*u.Y) &gt; 0 and offset or -offset 
						else
							local u = obj.EarthingAlignment.RcAlignment.EndTangent
							return ((ps.X-geoCoord.X)*u.X + (ps.Y-geoCoord.Y)*u.Y) &gt; 0 and offset or -offset 
						end
					end
				end
			end
        </Formula>
    </LuaFunction>



<!--========================================================================================================
	NOBN_trk_YyyyZzzz
	Track - general position issues, relative to track alignments, used by all objects.
	See also the Lua source files for track objects and track connections.
=========================================================================================================-->
	<LuaFunction Name="NOBN_trk_toKm()" ReturnType="String"
		Description="Converts input x [m] into mileage [km] with precision p (0..6), default precision is 3. E.g., 462371.637 => 462.372.">
		<Signature>Double NOBN_trk_toKm(Double x [, Int p])</Signature>
		<Formula>
			function NOBN_trk_toKm(x,p) 
				p = type(p) == "number" and math.floor(p) or 3
				if (x == nil) or (x ~= x) or (x == "") then
					--Note: x ~= x if and only if x is NaN (not-a-number)
					return 0, _warning
				end
				if p &lt; 0 or p &gt; 6 then
					return x,_info("Precision ["..p.."] must be from 0 to 6, cannot format value ["..x.."]"),_warning
				else
					return string.format("%."..p.."f", math.floor((x + 0.5*10^(3-p)) * 10^(p-3)) * 10^(-p) )
				end
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_trk_getNearestEntireKm()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when also half km is to be shown, e.g., 461.749 => 461 (half km is 5) and 461.750 => 462 (half km is 0).">
		<Signature>Int NOBN_trk_getNearestEntireKm([RailwayPlacedObject obj])</Signature>
		<Formula>
			function NOBN_trk_getNearestEntireKm(obj)
				obj = obj or this
				return math.floor(math.floor((obj:getPropertyValue("ReferenceMileage")/500)+.5)/2)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_trk_getNearestEntireKm2()" ReturnType="String"
		Description="Returns object's reference mileage's whole km when the half km is not to be shown, e.g., 461.499 => 461 and 461.500 => 462.">
		<Signature>Int NOBN_trk_getNearestEntireKm2([RailwayPlacedObject obj])</Signature>
		<Formula>
			function NOBN_trk_getNearestEntireKm2(obj)
				obj = obj or this
				return math.floor(math.floor(obj:getPropertyValue("ReferenceMileage")/1000 + 0.5))
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_trk_getNearestHalfKm()" ReturnType="String"
		Description="Returns object's reference mileage's half km (0 or 5), e.g., 461.750 => 0 (whole km is 461) and 462.372 => 5 (whole km is 462).">
		<Signature>Int NOBN_trk_getNearestHalfKm([RailwayPlacedObject obj])</Signature>
		<Formula>
			function NOBN_trk_getNearestHalfKm(obj)
				obj = obj or this
				return (math.floor((obj:getPropertyValue("ReferenceMileage")/500)+0.5)%2)*5
			end
		</Formula>
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_trk_getNearestHectometricSnap()" ReturnType="String"
		Description="Returns object's reference mileage's nearest whole hectometer.\n\nNote: The ReferenceMileage value may be rounded to a value outside the alignment. In that case the Hectometer symbol will be dropped at a non-integer multiple of 100m.">
		<Signature>Int NOBN_trk_getNearestHectometricSnap([RailwayPlacedObject obj])</Signature>
		<Formula>
			function NOBN_trk_getNearestHectometricSnap(obj)
				obj = obj or this
				return 100 * ((50 + obj:getPropertyValue("ReferenceMileage")) // 100)
			end
		</Formula>
	</LuaFunction>

	
	
	<LuaFunction Name="NOBN_trk_getNearestKilometricSnap()" ReturnType="String"
		Description="Returns object's reference mileage's nearest whole kilometer.">
		<Signature>Int NOBN_trk_getNearestKilometricSnap([RailwayPlacedObject obj])</Signature>
		<Formula>
			function NOBN_trk_getNearestKilometricSnap(obj)
				obj = obj or this
				return 1000 * ((500 + obj:getPropertyValue("ReferenceMileage")) // 1000)
			end
		</Formula>
	</LuaFunction>

	
	
 	<LuaFunction Name="NOBN_trk_getLiftFromCant()" ReturnType="Double"
		Description="Returns a track-bound object's Z-coordinate offset above the gradient curve [m], consistent with own alignment's local cant. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument.">
		<Signature>Double NOBN_trk_getLiftFromCant([_position])</Signature>
		<Formula>
			function NOBN_trk_getLiftFromCant(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				local ai
				if where == nil then
					-- can be called from point objects:
					ai = getAlignmentInfo()
				else
					-- can be called from anywhere, including an alignment, as a sampled formula:
					ai = getAlignmentInfo(where)
				end
				local cg, lwc, dta
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
					lwc = Alignment.AlignmentSystem.LiftWithCant
					dta = DistanceToAlignment
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
					lwc = AlignmentSystem.LiftWithCant
					dta = 0.0 --DistanceToAlignment
				end
				if not lwc then 
					return 0.0, _info("Alignment system does not lift with cant.")
				end
				local c = ai.Cant
				if c == nil or RC__isNan(c) then
					return 0.0, _info("UNFINISHED - No cant data in alignment, assuming zero cant.")
				elseif c == 0 then
					return 0.0
				else
					-- Cant is measured in millimeter superelevation
					-- Ask alignment system whether cant leads to lift or not:
					local h = c/1000.0 --[m]
					local msg
					if h &gt; cg then 
						h = cg - 0.001 -- Almost 90 degrees roll...
						msg = "Cant truncated to max, "..RC__round(1000*h).." mm."
					else
						msg = RC__round(1000*h).." mm cant."
					end
					local railSeparationXY = math.sqrt(cg^2 - h^2)
					if h == 0.0 then
						return 0.0, _info(msg)
					else
						local cr = ai.CantRotation
						if cr == "CCW" then
							-- Right rail lifted above left rail
							return h/2 + h/2 * dta / (railSeparationXY / 2)
						elseif cr == "CW" then
							-- Left rail lifted above right rail
							return h/2 - h/2 * dta / (railSeparationXY / 2)
						else
							return 0.0,_error, _info("Bad cant rotation direction ["..ai.CantRotation.."], assuming zero lift.")
						end
					end
				end
			end
		</Formula>		
	</LuaFunction>
	
	
	
	<LuaFunction Name="NOBN_trk_getLateralOffsetFromCantAndTrackPlaneDistance()" ReturnType="Double"
		Description="Returns a track-bound object's 2D distance to the alignment axis (IFC:gradient curve) as a function of its track plane distance to own model insertion axis. 'TrackPlaneDistance' is by default set to half of the rail separation (track gauge). If called from an alignment object, the reserved identifier '_position' holding a {Pos, Ref} must be provided as an input argument.">
		<Signature>Double NOBN_trk_getLateralOffsetFromCantAndTrackPlaneDistance([Double TrackPlaneDistance [,_position]])</Signature>
		<Formula>
			function NOBN_trk_getLateralOffsetFromCantAndTrackPlaneDistance(TrackPlaneDistance,where)
				local cg
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
				end
				if TrackPlaneDistance == nil then
					--No specific distance as input, use side of track and place on rail:
					TrackPlaneDistance = RightSided and cg/2.0 or -cg/2.0
				end
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				local ai
				if where == nil then
					-- Assume function has been called from a point object:
					ai = getAlignmentInfo()
				else
					ai = getAlignmentInfo(where)
				end
				local g = ai.Gradient
				local h = ai.Cant/1000.0
				if RC__isNan(h) then 
					return TrackPlaneDistance, _info("No cant data in alignment, assuming zero cant.")
				else
					-- Scale track plane distance to alignment with effect of cant:
					return TrackPlaneDistance * math.sqrt(1 - (h/cg)^2)
				end
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_trk_getRollFromCant()" ReturnType="Double"
		Description="Returns a track-bound object's sideways roll [Decimal Degrees], consistent with own alignment's local cant and object direction up/down. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument.">
		<Signature>Double NOBN_trk_getRollFromCant([_position])</Signature>
		<Formula>
			function NOBN_trk_getRollFromCant(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC as 'where', sampled along the alignment.
				--'where' is a data structure, if present, consisting of .Pos and .Ref
				local ai
				if where == nil then
					-- Assume function was called from a point object:
					ai = getAlignmentInfo()
				else
					-- can be called from anywhere, including an alignment, as a sampled formula:
					ai = getAlignmentInfo(where)
				end
				local cg
				if RcAlignment == nil then 
					-- 'this' is a point object:
					cg = Alignment.AlignmentSystem.CantGauge
				else 
					-- 'this' is an alignment:
					cg = AlignmentSystem.CantGauge
				end
				local c = ai.Cant
				if c == nil or RC__isNan(c) then
					return 0.0, _info("UNFINISHED - No cant data in alignment, assuming zero cant.")
				elseif c == 0 then
					return 0.0
				else
					-- Cant is measured in millimeter superelevation, with rotation clockwise or counterclockwise in the track's direction
					-- Assume that only one rail is lifted at a time.
					local h = c/1000.0
					local cr = tostring(ai.CantRotation)
					if cr:upper() == "CW" then
						return math.asin(h/cg)*(180/math.pi)
					elseif cr:upper() == "CCW" then 
						return -math.asin(h/cg)*(180/math.pi)
					else
						return 90.0,_error, _info("Bad cant rotation data ["..ai.CantRotation.."], assuming 90 degrees roll as a visual warning.")
					end
				end
			end
		</Formula>
	</LuaFunction>



	<LuaFunction Name="NOBN_com_getRollFromCantInterpretedAsDecimalDegrees()" ReturnType="Double"
		Description="Returns a roll angle deduced from an alignment's cant, where Cant is interpreted as decimal degrees and CW/CCW.">
		<Signature>Double NOBN_com_getRollFromCantInterpretedAsDecimalDegrees([_position])</Signature>
		<Formula>
			function NOBN_com_getRollFromCantInterpretedAsDecimalDegrees(where)
				--If called to express e.g. a road, or OCS wire clamps or sweeping a contact wire, then '_position' is provided by RC, sampled along the alignment.
				local ai
				if where == nil then
					ai = getAlignmentInfo()
				else
					ai = getAlignmentInfo(where)
				end
				local angleInDecimalDegrees = ai.Cant --  NB! Cant is interpreted as decimal degrees CW/CCW.
				if (RC__isNan(angleInDecimalDegrees)) then
					return 0, _info("UNFINISHED - No cant (to be interpreted as an angle in decimal degrees) data in non-track alignment, assuming zero cant.")
				elseif angleInDecimalDegrees == 0 then
					return 0
				else
					-- Cant is measured in millimeter superelevation, with rotation clockwise or counterclockwise in the track's direction
					-- Assume that only one rail is lifted at a time.
					local cr = tostring(ai.CantRotation or "No data")
					if  cr:upper() == "CW" then
						return angleInDecimalDegrees
					elseif cr:upper() == "CCW" then 
						return -angleInDecimalDegrees
					else
						return 90.0,_error, _info("Bad cant rotation data ["..cr.."], assuming 90 degrees roll as a visual warning.")
					end
				end
			end
		</Formula>
	</LuaFunction>


	
	<LuaFunction Name="NOBN_trk_getPitchFromGradient()" ReturnType="Double"
		Description="Returns a track-bound object's pitch [decimal degrees], consistent with own alignment's local gradient, and object orientation up/down/both/none. If called from an alignment object, the reserved identifier '_position' must be provided as an input argument.">
		<Signature>Double NOBN_trk_getPitchFromGradient([_position])</Signature>
		<Formula>
			function NOBN_trk_getPitchFromGradient(where)
				--If called to express e.g. sleepers and rails for a 3D alignment, then '_position' is provided by RC, sampled along the alignment.
				local g
				if where == nil then
					g = getAlignmentInfo().Gradient
				else
					g = getAlignmentInfo(where).Gradient 
				end
				if RC__isNan(g) then
					return 0.0, _info("UNFINISHED - No gradient data in alignment, assuming zero gradient.")
				else
					return math.deg(math.atan(g/1000))
				end
			end
		</Formula>
	</LuaFunction>
	
	
	
    <LuaFunction Name="NOBN_trk_getYawFromDir()" ReturnType="Double"
		Description="Returns the 3D rotation of an object [Decimal Degrees] according to its orientation ('dir' property up/down/none/both) and its lateral position in relation to the axis, in the direction of increasing PKs. If a 'rotation' argument [DD] is supplied, its value will be added to the base angle [0|90|180|270] corresponding to the 'dir' property and the side of the object's axis. If no 'rotation' argument has been supplied, the intrinsic 'AngularOffset' property [DD] will be added to the basic rotation. Objects which do not feature the 'dir' property will return 0.">
        <Signature>Double NOBN_trk_getYawFromDir([Double rotation])</Signature>
		<Formula>
			function NOBN_trk_getYawFromDir(rotation)
				local d = getPropertyValue("dir") --Strip off _symbol and _info() if any, get just the plain string value
				if d == nil then return 0 end
				if rotation == nil and AngularOffset == nil then
					-- No argument given, and no standard property 'AngularOffset' exists for the current object
					if d == 'up' then
						return 0.0
					elseif d == 'down' then
						return 180.0
					elseif d == 'both' then
						return RightSided and -90.0 or 90.0
					elseif d == 'none' then
						return RightSided and 90.0 or -90.0
					else --d == unknown':
						return 45.0,_warning, _info("EnableDirectionSetting is 'unknown', cannot compute yaw, assuming 45 degrees as a visual warning.")
					end
				else
					--Modify 'dir' with extra rotation:
					if rotation == nil then
						--No arg given, use object's own AngularOffset:
						rotation = AngularOffset
					else 
						if math.abs(rotation) &lt; 4e-4 then 
							rotation = 0.0 --remove small inaccuracies
						end
					end
					if d == 'up' then
						return rotation, _info("'up' with "..rotation.." degrees extra rotation.")
					elseif d == 'down' then
						return 180.0+rotation, _info("'down' with "..rotation.." degrees extra rotation.")
					elseif d == 'both' then
						return (RightSided and -90.0 or 90.0) + rotation, _info("'both' with "..rotation.." degrees extra rotation.")
					elseif d == 'none' then
						return (RightSided and 90.0 or -90.0) + rotation, _info("'none' with "..rotation.." degrees extra rotation.")
					else --d == unknown':
						return 45.0,_warning, _info("The basic direction is 'unknown', cannot compute yaw, assuming 45 degrees as a visual warning .")
					end
				end
			end
		</Formula>
	</LuaFunction>

	
	
<!--========================================================================================================
    End of file 
=========================================================================================================-->
</xpp:bloc>
